// DO NOT EDIT: @generated by erupt's generator
///<s>Vulkan Manual Page</s> · Constant
pub const FN_GET_DEVICE_BUFFER_MEMORY_REQUIREMENTS: *const std::os::raw::c_char = crate::cstr!(
    "vkGetDeviceBufferMemoryRequirements"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_GET_DEVICE_IMAGE_MEMORY_REQUIREMENTS: *const std::os::raw::c_char = crate::cstr!(
    "vkGetDeviceImageMemoryRequirements"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_GET_DEVICE_IMAGE_SPARSE_MEMORY_REQUIREMENTS: *const std::os::raw::c_char = crate::cstr!(
    "vkGetDeviceImageSparseMemoryRequirements"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_GET_PHYSICAL_DEVICE_TOOL_PROPERTIES: *const std::os::raw::c_char = crate::cstr!(
    "vkGetPhysicalDeviceToolProperties"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_CULL_MODE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetCullMode"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_FRONT_FACE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetFrontFace"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_PRIMITIVE_TOPOLOGY: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetPrimitiveTopology"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_VIEWPORT_WITH_COUNT: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetViewportWithCount"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_SCISSOR_WITH_COUNT: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetScissorWithCount"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_BIND_VERTEX_BUFFERS2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdBindVertexBuffers2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_DEPTH_TEST_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetDepthTestEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_DEPTH_WRITE_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetDepthWriteEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_DEPTH_COMPARE_OP: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetDepthCompareOp"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_DEPTH_BOUNDS_TEST_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetDepthBoundsTestEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_STENCIL_TEST_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetStencilTestEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_STENCIL_OP: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetStencilOp"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_RASTERIZER_DISCARD_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetRasterizerDiscardEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_DEPTH_BIAS_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetDepthBiasEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_PRIMITIVE_RESTART_ENABLE: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetPrimitiveRestartEnable"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CREATE_PRIVATE_DATA_SLOT: *const std::os::raw::c_char = crate::cstr!(
    "vkCreatePrivateDataSlot"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_DESTROY_PRIVATE_DATA_SLOT: *const std::os::raw::c_char = crate::cstr!(
    "vkDestroyPrivateDataSlot"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_SET_PRIVATE_DATA: *const std::os::raw::c_char = crate::cstr!(
    "vkSetPrivateData"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_GET_PRIVATE_DATA: *const std::os::raw::c_char = crate::cstr!(
    "vkGetPrivateData"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_COPY_BUFFER2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdCopyBuffer2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_COPY_IMAGE2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdCopyImage2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_BLIT_IMAGE2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdBlitImage2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_COPY_BUFFER_TO_IMAGE2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdCopyBufferToImage2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_COPY_IMAGE_TO_BUFFER2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdCopyImageToBuffer2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_RESOLVE_IMAGE2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdResolveImage2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_SET_EVENT2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdSetEvent2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_RESET_EVENT2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdResetEvent2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_WAIT_EVENTS2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdWaitEvents2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_PIPELINE_BARRIER2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdPipelineBarrier2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_QUEUE_SUBMIT2: *const std::os::raw::c_char = crate::cstr!("vkQueueSubmit2");
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_WRITE_TIMESTAMP2: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdWriteTimestamp2"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_BEGIN_RENDERING: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdBeginRendering"
);
///<s>Vulkan Manual Page</s> · Constant
pub const FN_CMD_END_RENDERING: *const std::os::raw::c_char = crate::cstr!(
    "vkCmdEndRendering"
);
crate::non_dispatchable_handle!(
    PrivateDataSlot, PRIVATE_DATA_SLOT,
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html) · Non-dispatchable Handle",
    "VkPrivateDataSlot"
);
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlags2.html) · Bitmask of [`AccessFlagBits2`]"]
    #[doc(alias = "VkAccessFlags2")] #[derive(Default)] #[repr(transparent)] pub struct
    AccessFlags2 : u64 { const NONE = AccessFlagBits2::NONE.0; const NONE_KHR =
    AccessFlagBits2::NONE_KHR.0; const INDIRECT_COMMAND_READ =
    AccessFlagBits2::INDIRECT_COMMAND_READ.0; const INDIRECT_COMMAND_READ_KHR =
    AccessFlagBits2::INDIRECT_COMMAND_READ_KHR.0; const INDEX_READ =
    AccessFlagBits2::INDEX_READ.0; const INDEX_READ_KHR =
    AccessFlagBits2::INDEX_READ_KHR.0; const VERTEX_ATTRIBUTE_READ =
    AccessFlagBits2::VERTEX_ATTRIBUTE_READ.0; const VERTEX_ATTRIBUTE_READ_KHR =
    AccessFlagBits2::VERTEX_ATTRIBUTE_READ_KHR.0; const UNIFORM_READ =
    AccessFlagBits2::UNIFORM_READ.0; const UNIFORM_READ_KHR =
    AccessFlagBits2::UNIFORM_READ_KHR.0; const INPUT_ATTACHMENT_READ =
    AccessFlagBits2::INPUT_ATTACHMENT_READ.0; const INPUT_ATTACHMENT_READ_KHR =
    AccessFlagBits2::INPUT_ATTACHMENT_READ_KHR.0; const SHADER_READ =
    AccessFlagBits2::SHADER_READ.0; const SHADER_READ_KHR =
    AccessFlagBits2::SHADER_READ_KHR.0; const SHADER_WRITE =
    AccessFlagBits2::SHADER_WRITE.0; const SHADER_WRITE_KHR =
    AccessFlagBits2::SHADER_WRITE_KHR.0; const COLOR_ATTACHMENT_READ =
    AccessFlagBits2::COLOR_ATTACHMENT_READ.0; const COLOR_ATTACHMENT_READ_KHR =
    AccessFlagBits2::COLOR_ATTACHMENT_READ_KHR.0; const COLOR_ATTACHMENT_WRITE =
    AccessFlagBits2::COLOR_ATTACHMENT_WRITE.0; const COLOR_ATTACHMENT_WRITE_KHR =
    AccessFlagBits2::COLOR_ATTACHMENT_WRITE_KHR.0; const DEPTH_STENCIL_ATTACHMENT_READ =
    AccessFlagBits2::DEPTH_STENCIL_ATTACHMENT_READ.0; const
    DEPTH_STENCIL_ATTACHMENT_READ_KHR =
    AccessFlagBits2::DEPTH_STENCIL_ATTACHMENT_READ_KHR.0; const
    DEPTH_STENCIL_ATTACHMENT_WRITE = AccessFlagBits2::DEPTH_STENCIL_ATTACHMENT_WRITE.0;
    const DEPTH_STENCIL_ATTACHMENT_WRITE_KHR =
    AccessFlagBits2::DEPTH_STENCIL_ATTACHMENT_WRITE_KHR.0; const TRANSFER_READ =
    AccessFlagBits2::TRANSFER_READ.0; const TRANSFER_READ_KHR =
    AccessFlagBits2::TRANSFER_READ_KHR.0; const TRANSFER_WRITE =
    AccessFlagBits2::TRANSFER_WRITE.0; const TRANSFER_WRITE_KHR =
    AccessFlagBits2::TRANSFER_WRITE_KHR.0; const HOST_READ =
    AccessFlagBits2::HOST_READ.0; const HOST_READ_KHR = AccessFlagBits2::HOST_READ_KHR.0;
    const HOST_WRITE = AccessFlagBits2::HOST_WRITE.0; const HOST_WRITE_KHR =
    AccessFlagBits2::HOST_WRITE_KHR.0; const MEMORY_READ =
    AccessFlagBits2::MEMORY_READ.0; const MEMORY_READ_KHR =
    AccessFlagBits2::MEMORY_READ_KHR.0; const MEMORY_WRITE =
    AccessFlagBits2::MEMORY_WRITE.0; const MEMORY_WRITE_KHR =
    AccessFlagBits2::MEMORY_WRITE_KHR.0; const SHADER_SAMPLED_READ =
    AccessFlagBits2::SHADER_SAMPLED_READ.0; const SHADER_SAMPLED_READ_KHR =
    AccessFlagBits2::SHADER_SAMPLED_READ_KHR.0; const SHADER_STORAGE_READ =
    AccessFlagBits2::SHADER_STORAGE_READ.0; const SHADER_STORAGE_READ_KHR =
    AccessFlagBits2::SHADER_STORAGE_READ_KHR.0; const SHADER_STORAGE_WRITE =
    AccessFlagBits2::SHADER_STORAGE_WRITE.0; const SHADER_STORAGE_WRITE_KHR =
    AccessFlagBits2::SHADER_STORAGE_WRITE_KHR.0; const VIDEO_DECODE_READ_KHR =
    AccessFlagBits2::VIDEO_DECODE_READ_KHR.0; const VIDEO_DECODE_WRITE_KHR =
    AccessFlagBits2::VIDEO_DECODE_WRITE_KHR.0; const VIDEO_ENCODE_READ_KHR =
    AccessFlagBits2::VIDEO_ENCODE_READ_KHR.0; const VIDEO_ENCODE_WRITE_KHR =
    AccessFlagBits2::VIDEO_ENCODE_WRITE_KHR.0; const TRANSFORM_FEEDBACK_WRITE_EXT =
    AccessFlagBits2::TRANSFORM_FEEDBACK_WRITE_EXT.0; const
    TRANSFORM_FEEDBACK_COUNTER_READ_EXT =
    AccessFlagBits2::TRANSFORM_FEEDBACK_COUNTER_READ_EXT.0; const
    TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT =
    AccessFlagBits2::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT.0; const
    CONDITIONAL_RENDERING_READ_EXT = AccessFlagBits2::CONDITIONAL_RENDERING_READ_EXT.0;
    const COMMAND_PREPROCESS_READ_NV = AccessFlagBits2::COMMAND_PREPROCESS_READ_NV.0;
    const COMMAND_PREPROCESS_WRITE_NV = AccessFlagBits2::COMMAND_PREPROCESS_WRITE_NV.0;
    const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR =
    AccessFlagBits2::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR.0; const
    SHADING_RATE_IMAGE_READ_NV = AccessFlagBits2::SHADING_RATE_IMAGE_READ_NV.0; const
    ACCELERATION_STRUCTURE_READ_KHR = AccessFlagBits2::ACCELERATION_STRUCTURE_READ_KHR.0;
    const ACCELERATION_STRUCTURE_WRITE_KHR =
    AccessFlagBits2::ACCELERATION_STRUCTURE_WRITE_KHR.0; const
    ACCELERATION_STRUCTURE_READ_NV = AccessFlagBits2::ACCELERATION_STRUCTURE_READ_NV.0;
    const ACCELERATION_STRUCTURE_WRITE_NV =
    AccessFlagBits2::ACCELERATION_STRUCTURE_WRITE_NV.0; const
    FRAGMENT_DENSITY_MAP_READ_EXT = AccessFlagBits2::FRAGMENT_DENSITY_MAP_READ_EXT.0;
    const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT =
    AccessFlagBits2::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT.0; const
    INVOCATION_MASK_READ_HUAWEI = AccessFlagBits2::INVOCATION_MASK_READ_HUAWEI.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits2.html) · Bits enum of [`AccessFlags2`]
#[doc(alias = "VkAccessFlagBits2")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct AccessFlagBits2(pub u64);
impl AccessFlagBits2 {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> AccessFlags2 {
        AccessFlags2::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for AccessFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::NONE => "NONE",
                    &Self::NONE_KHR => "NONE_KHR",
                    &Self::INDIRECT_COMMAND_READ => "INDIRECT_COMMAND_READ",
                    &Self::INDIRECT_COMMAND_READ_KHR => "INDIRECT_COMMAND_READ_KHR",
                    &Self::INDEX_READ => "INDEX_READ",
                    &Self::INDEX_READ_KHR => "INDEX_READ_KHR",
                    &Self::VERTEX_ATTRIBUTE_READ => "VERTEX_ATTRIBUTE_READ",
                    &Self::VERTEX_ATTRIBUTE_READ_KHR => "VERTEX_ATTRIBUTE_READ_KHR",
                    &Self::UNIFORM_READ => "UNIFORM_READ",
                    &Self::UNIFORM_READ_KHR => "UNIFORM_READ_KHR",
                    &Self::INPUT_ATTACHMENT_READ => "INPUT_ATTACHMENT_READ",
                    &Self::INPUT_ATTACHMENT_READ_KHR => "INPUT_ATTACHMENT_READ_KHR",
                    &Self::SHADER_READ => "SHADER_READ",
                    &Self::SHADER_READ_KHR => "SHADER_READ_KHR",
                    &Self::SHADER_WRITE => "SHADER_WRITE",
                    &Self::SHADER_WRITE_KHR => "SHADER_WRITE_KHR",
                    &Self::COLOR_ATTACHMENT_READ => "COLOR_ATTACHMENT_READ",
                    &Self::COLOR_ATTACHMENT_READ_KHR => "COLOR_ATTACHMENT_READ_KHR",
                    &Self::COLOR_ATTACHMENT_WRITE => "COLOR_ATTACHMENT_WRITE",
                    &Self::COLOR_ATTACHMENT_WRITE_KHR => "COLOR_ATTACHMENT_WRITE_KHR",
                    &Self::DEPTH_STENCIL_ATTACHMENT_READ => {
                        "DEPTH_STENCIL_ATTACHMENT_READ"
                    }
                    &Self::DEPTH_STENCIL_ATTACHMENT_READ_KHR => {
                        "DEPTH_STENCIL_ATTACHMENT_READ_KHR"
                    }
                    &Self::DEPTH_STENCIL_ATTACHMENT_WRITE => {
                        "DEPTH_STENCIL_ATTACHMENT_WRITE"
                    }
                    &Self::DEPTH_STENCIL_ATTACHMENT_WRITE_KHR => {
                        "DEPTH_STENCIL_ATTACHMENT_WRITE_KHR"
                    }
                    &Self::TRANSFER_READ => "TRANSFER_READ",
                    &Self::TRANSFER_READ_KHR => "TRANSFER_READ_KHR",
                    &Self::TRANSFER_WRITE => "TRANSFER_WRITE",
                    &Self::TRANSFER_WRITE_KHR => "TRANSFER_WRITE_KHR",
                    &Self::HOST_READ => "HOST_READ",
                    &Self::HOST_READ_KHR => "HOST_READ_KHR",
                    &Self::HOST_WRITE => "HOST_WRITE",
                    &Self::HOST_WRITE_KHR => "HOST_WRITE_KHR",
                    &Self::MEMORY_READ => "MEMORY_READ",
                    &Self::MEMORY_READ_KHR => "MEMORY_READ_KHR",
                    &Self::MEMORY_WRITE => "MEMORY_WRITE",
                    &Self::MEMORY_WRITE_KHR => "MEMORY_WRITE_KHR",
                    &Self::SHADER_SAMPLED_READ => "SHADER_SAMPLED_READ",
                    &Self::SHADER_SAMPLED_READ_KHR => "SHADER_SAMPLED_READ_KHR",
                    &Self::SHADER_STORAGE_READ => "SHADER_STORAGE_READ",
                    &Self::SHADER_STORAGE_READ_KHR => "SHADER_STORAGE_READ_KHR",
                    &Self::SHADER_STORAGE_WRITE => "SHADER_STORAGE_WRITE",
                    &Self::SHADER_STORAGE_WRITE_KHR => "SHADER_STORAGE_WRITE_KHR",
                    &Self::VIDEO_DECODE_READ_KHR => "VIDEO_DECODE_READ_KHR",
                    &Self::VIDEO_DECODE_WRITE_KHR => "VIDEO_DECODE_WRITE_KHR",
                    &Self::VIDEO_ENCODE_READ_KHR => "VIDEO_ENCODE_READ_KHR",
                    &Self::VIDEO_ENCODE_WRITE_KHR => "VIDEO_ENCODE_WRITE_KHR",
                    &Self::TRANSFORM_FEEDBACK_WRITE_EXT => "TRANSFORM_FEEDBACK_WRITE_EXT",
                    &Self::TRANSFORM_FEEDBACK_COUNTER_READ_EXT => {
                        "TRANSFORM_FEEDBACK_COUNTER_READ_EXT"
                    }
                    &Self::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT => {
                        "TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT"
                    }
                    &Self::CONDITIONAL_RENDERING_READ_EXT => {
                        "CONDITIONAL_RENDERING_READ_EXT"
                    }
                    &Self::COMMAND_PREPROCESS_READ_NV => "COMMAND_PREPROCESS_READ_NV",
                    &Self::COMMAND_PREPROCESS_WRITE_NV => "COMMAND_PREPROCESS_WRITE_NV",
                    &Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR => {
                        "FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR"
                    }
                    &Self::SHADING_RATE_IMAGE_READ_NV => "SHADING_RATE_IMAGE_READ_NV",
                    &Self::ACCELERATION_STRUCTURE_READ_KHR => {
                        "ACCELERATION_STRUCTURE_READ_KHR"
                    }
                    &Self::ACCELERATION_STRUCTURE_WRITE_KHR => {
                        "ACCELERATION_STRUCTURE_WRITE_KHR"
                    }
                    &Self::ACCELERATION_STRUCTURE_READ_NV => {
                        "ACCELERATION_STRUCTURE_READ_NV"
                    }
                    &Self::ACCELERATION_STRUCTURE_WRITE_NV => {
                        "ACCELERATION_STRUCTURE_WRITE_NV"
                    }
                    &Self::FRAGMENT_DENSITY_MAP_READ_EXT => {
                        "FRAGMENT_DENSITY_MAP_READ_EXT"
                    }
                    &Self::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT => {
                        "COLOR_ATTACHMENT_READ_NONCOHERENT_EXT"
                    }
                    &Self::INVOCATION_MASK_READ_HUAWEI => "INVOCATION_MASK_READ_HUAWEI",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::AccessFlagBits2 {
    pub const NONE: Self = Self(0);
    pub const NONE_KHR: Self = Self(0);
    pub const INDIRECT_COMMAND_READ: Self = Self(1);
    pub const INDIRECT_COMMAND_READ_KHR: Self = Self(1);
    pub const INDEX_READ: Self = Self(2);
    pub const INDEX_READ_KHR: Self = Self(2);
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(4);
    pub const VERTEX_ATTRIBUTE_READ_KHR: Self = Self(4);
    pub const UNIFORM_READ: Self = Self(8);
    pub const UNIFORM_READ_KHR: Self = Self(8);
    pub const INPUT_ATTACHMENT_READ: Self = Self(16);
    pub const INPUT_ATTACHMENT_READ_KHR: Self = Self(16);
    pub const SHADER_READ: Self = Self(32);
    pub const SHADER_READ_KHR: Self = Self(32);
    pub const SHADER_WRITE: Self = Self(64);
    pub const SHADER_WRITE_KHR: Self = Self(64);
    pub const COLOR_ATTACHMENT_READ: Self = Self(128);
    pub const COLOR_ATTACHMENT_READ_KHR: Self = Self(128);
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(256);
    pub const COLOR_ATTACHMENT_WRITE_KHR: Self = Self(256);
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    pub const DEPTH_STENCIL_ATTACHMENT_READ_KHR: Self = Self(512);
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE_KHR: Self = Self(1024);
    pub const TRANSFER_READ: Self = Self(2048);
    pub const TRANSFER_READ_KHR: Self = Self(2048);
    pub const TRANSFER_WRITE: Self = Self(4096);
    pub const TRANSFER_WRITE_KHR: Self = Self(4096);
    pub const HOST_READ: Self = Self(8192);
    pub const HOST_READ_KHR: Self = Self(8192);
    pub const HOST_WRITE: Self = Self(16384);
    pub const HOST_WRITE_KHR: Self = Self(16384);
    pub const MEMORY_READ: Self = Self(32768);
    pub const MEMORY_READ_KHR: Self = Self(32768);
    pub const MEMORY_WRITE: Self = Self(65536);
    pub const MEMORY_WRITE_KHR: Self = Self(65536);
    pub const SHADER_SAMPLED_READ: Self = Self(4294967296);
    pub const SHADER_SAMPLED_READ_KHR: Self = Self(4294967296);
    pub const SHADER_STORAGE_READ: Self = Self(8589934592);
    pub const SHADER_STORAGE_READ_KHR: Self = Self(8589934592);
    pub const SHADER_STORAGE_WRITE: Self = Self(17179869184);
    pub const SHADER_STORAGE_WRITE_KHR: Self = Self(17179869184);
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlags2.html) · Bitmask of [`PipelineStageFlagBits2`]"]
    #[doc(alias = "VkPipelineStageFlags2")] #[derive(Default)] #[repr(transparent)] pub
    struct PipelineStageFlags2 : u64 { const NONE = PipelineStageFlagBits2::NONE.0; const
    NONE_KHR = PipelineStageFlagBits2::NONE_KHR.0; const TOP_OF_PIPE =
    PipelineStageFlagBits2::TOP_OF_PIPE.0; const TOP_OF_PIPE_KHR =
    PipelineStageFlagBits2::TOP_OF_PIPE_KHR.0; const DRAW_INDIRECT =
    PipelineStageFlagBits2::DRAW_INDIRECT.0; const DRAW_INDIRECT_KHR =
    PipelineStageFlagBits2::DRAW_INDIRECT_KHR.0; const VERTEX_INPUT =
    PipelineStageFlagBits2::VERTEX_INPUT.0; const VERTEX_INPUT_KHR =
    PipelineStageFlagBits2::VERTEX_INPUT_KHR.0; const VERTEX_SHADER =
    PipelineStageFlagBits2::VERTEX_SHADER.0; const VERTEX_SHADER_KHR =
    PipelineStageFlagBits2::VERTEX_SHADER_KHR.0; const TESSELLATION_CONTROL_SHADER =
    PipelineStageFlagBits2::TESSELLATION_CONTROL_SHADER.0; const
    TESSELLATION_CONTROL_SHADER_KHR =
    PipelineStageFlagBits2::TESSELLATION_CONTROL_SHADER_KHR.0; const
    TESSELLATION_EVALUATION_SHADER =
    PipelineStageFlagBits2::TESSELLATION_EVALUATION_SHADER.0; const
    TESSELLATION_EVALUATION_SHADER_KHR =
    PipelineStageFlagBits2::TESSELLATION_EVALUATION_SHADER_KHR.0; const GEOMETRY_SHADER =
    PipelineStageFlagBits2::GEOMETRY_SHADER.0; const GEOMETRY_SHADER_KHR =
    PipelineStageFlagBits2::GEOMETRY_SHADER_KHR.0; const FRAGMENT_SHADER =
    PipelineStageFlagBits2::FRAGMENT_SHADER.0; const FRAGMENT_SHADER_KHR =
    PipelineStageFlagBits2::FRAGMENT_SHADER_KHR.0; const EARLY_FRAGMENT_TESTS =
    PipelineStageFlagBits2::EARLY_FRAGMENT_TESTS.0; const EARLY_FRAGMENT_TESTS_KHR =
    PipelineStageFlagBits2::EARLY_FRAGMENT_TESTS_KHR.0; const LATE_FRAGMENT_TESTS =
    PipelineStageFlagBits2::LATE_FRAGMENT_TESTS.0; const LATE_FRAGMENT_TESTS_KHR =
    PipelineStageFlagBits2::LATE_FRAGMENT_TESTS_KHR.0; const COLOR_ATTACHMENT_OUTPUT =
    PipelineStageFlagBits2::COLOR_ATTACHMENT_OUTPUT.0; const COLOR_ATTACHMENT_OUTPUT_KHR
    = PipelineStageFlagBits2::COLOR_ATTACHMENT_OUTPUT_KHR.0; const COMPUTE_SHADER =
    PipelineStageFlagBits2::COMPUTE_SHADER.0; const COMPUTE_SHADER_KHR =
    PipelineStageFlagBits2::COMPUTE_SHADER_KHR.0; const ALL_TRANSFER =
    PipelineStageFlagBits2::ALL_TRANSFER.0; const ALL_TRANSFER_KHR =
    PipelineStageFlagBits2::ALL_TRANSFER_KHR.0; const TRANSFER =
    PipelineStageFlagBits2::TRANSFER.0; const TRANSFER_KHR =
    PipelineStageFlagBits2::TRANSFER_KHR.0; const BOTTOM_OF_PIPE =
    PipelineStageFlagBits2::BOTTOM_OF_PIPE.0; const BOTTOM_OF_PIPE_KHR =
    PipelineStageFlagBits2::BOTTOM_OF_PIPE_KHR.0; const HOST =
    PipelineStageFlagBits2::HOST.0; const HOST_KHR = PipelineStageFlagBits2::HOST_KHR.0;
    const ALL_GRAPHICS = PipelineStageFlagBits2::ALL_GRAPHICS.0; const ALL_GRAPHICS_KHR =
    PipelineStageFlagBits2::ALL_GRAPHICS_KHR.0; const ALL_COMMANDS =
    PipelineStageFlagBits2::ALL_COMMANDS.0; const ALL_COMMANDS_KHR =
    PipelineStageFlagBits2::ALL_COMMANDS_KHR.0; const COPY =
    PipelineStageFlagBits2::COPY.0; const COPY_KHR = PipelineStageFlagBits2::COPY_KHR.0;
    const RESOLVE = PipelineStageFlagBits2::RESOLVE.0; const RESOLVE_KHR =
    PipelineStageFlagBits2::RESOLVE_KHR.0; const BLIT = PipelineStageFlagBits2::BLIT.0;
    const BLIT_KHR = PipelineStageFlagBits2::BLIT_KHR.0; const CLEAR =
    PipelineStageFlagBits2::CLEAR.0; const CLEAR_KHR =
    PipelineStageFlagBits2::CLEAR_KHR.0; const INDEX_INPUT =
    PipelineStageFlagBits2::INDEX_INPUT.0; const INDEX_INPUT_KHR =
    PipelineStageFlagBits2::INDEX_INPUT_KHR.0; const VERTEX_ATTRIBUTE_INPUT =
    PipelineStageFlagBits2::VERTEX_ATTRIBUTE_INPUT.0; const VERTEX_ATTRIBUTE_INPUT_KHR =
    PipelineStageFlagBits2::VERTEX_ATTRIBUTE_INPUT_KHR.0; const PRE_RASTERIZATION_SHADERS
    = PipelineStageFlagBits2::PRE_RASTERIZATION_SHADERS.0; const
    PRE_RASTERIZATION_SHADERS_KHR =
    PipelineStageFlagBits2::PRE_RASTERIZATION_SHADERS_KHR.0; const VIDEO_DECODE_KHR =
    PipelineStageFlagBits2::VIDEO_DECODE_KHR.0; const VIDEO_ENCODE_KHR =
    PipelineStageFlagBits2::VIDEO_ENCODE_KHR.0; const TRANSFORM_FEEDBACK_EXT =
    PipelineStageFlagBits2::TRANSFORM_FEEDBACK_EXT.0; const CONDITIONAL_RENDERING_EXT =
    PipelineStageFlagBits2::CONDITIONAL_RENDERING_EXT.0; const COMMAND_PREPROCESS_NV =
    PipelineStageFlagBits2::COMMAND_PREPROCESS_NV.0; const
    FRAGMENT_SHADING_RATE_ATTACHMENT_KHR =
    PipelineStageFlagBits2::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.0; const
    SHADING_RATE_IMAGE_NV = PipelineStageFlagBits2::SHADING_RATE_IMAGE_NV.0; const
    ACCELERATION_STRUCTURE_BUILD_KHR =
    PipelineStageFlagBits2::ACCELERATION_STRUCTURE_BUILD_KHR.0; const
    RAY_TRACING_SHADER_KHR = PipelineStageFlagBits2::RAY_TRACING_SHADER_KHR.0; const
    RAY_TRACING_SHADER_NV = PipelineStageFlagBits2::RAY_TRACING_SHADER_NV.0; const
    ACCELERATION_STRUCTURE_BUILD_NV =
    PipelineStageFlagBits2::ACCELERATION_STRUCTURE_BUILD_NV.0; const
    FRAGMENT_DENSITY_PROCESS_EXT =
    PipelineStageFlagBits2::FRAGMENT_DENSITY_PROCESS_EXT.0; const TASK_SHADER_NV =
    PipelineStageFlagBits2::TASK_SHADER_NV.0; const MESH_SHADER_NV =
    PipelineStageFlagBits2::MESH_SHADER_NV.0; const SUBPASS_SHADING_HUAWEI =
    PipelineStageFlagBits2::SUBPASS_SHADING_HUAWEI.0; const INVOCATION_MASK_HUAWEI =
    PipelineStageFlagBits2::INVOCATION_MASK_HUAWEI.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits2.html) · Bits enum of [`PipelineStageFlags2`]
#[doc(alias = "VkPipelineStageFlagBits2")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct PipelineStageFlagBits2(pub u64);
impl PipelineStageFlagBits2 {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> PipelineStageFlags2 {
        PipelineStageFlags2::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for PipelineStageFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::NONE => "NONE",
                    &Self::NONE_KHR => "NONE_KHR",
                    &Self::TOP_OF_PIPE => "TOP_OF_PIPE",
                    &Self::TOP_OF_PIPE_KHR => "TOP_OF_PIPE_KHR",
                    &Self::DRAW_INDIRECT => "DRAW_INDIRECT",
                    &Self::DRAW_INDIRECT_KHR => "DRAW_INDIRECT_KHR",
                    &Self::VERTEX_INPUT => "VERTEX_INPUT",
                    &Self::VERTEX_INPUT_KHR => "VERTEX_INPUT_KHR",
                    &Self::VERTEX_SHADER => "VERTEX_SHADER",
                    &Self::VERTEX_SHADER_KHR => "VERTEX_SHADER_KHR",
                    &Self::TESSELLATION_CONTROL_SHADER => "TESSELLATION_CONTROL_SHADER",
                    &Self::TESSELLATION_CONTROL_SHADER_KHR => {
                        "TESSELLATION_CONTROL_SHADER_KHR"
                    }
                    &Self::TESSELLATION_EVALUATION_SHADER => {
                        "TESSELLATION_EVALUATION_SHADER"
                    }
                    &Self::TESSELLATION_EVALUATION_SHADER_KHR => {
                        "TESSELLATION_EVALUATION_SHADER_KHR"
                    }
                    &Self::GEOMETRY_SHADER => "GEOMETRY_SHADER",
                    &Self::GEOMETRY_SHADER_KHR => "GEOMETRY_SHADER_KHR",
                    &Self::FRAGMENT_SHADER => "FRAGMENT_SHADER",
                    &Self::FRAGMENT_SHADER_KHR => "FRAGMENT_SHADER_KHR",
                    &Self::EARLY_FRAGMENT_TESTS => "EARLY_FRAGMENT_TESTS",
                    &Self::EARLY_FRAGMENT_TESTS_KHR => "EARLY_FRAGMENT_TESTS_KHR",
                    &Self::LATE_FRAGMENT_TESTS => "LATE_FRAGMENT_TESTS",
                    &Self::LATE_FRAGMENT_TESTS_KHR => "LATE_FRAGMENT_TESTS_KHR",
                    &Self::COLOR_ATTACHMENT_OUTPUT => "COLOR_ATTACHMENT_OUTPUT",
                    &Self::COLOR_ATTACHMENT_OUTPUT_KHR => "COLOR_ATTACHMENT_OUTPUT_KHR",
                    &Self::COMPUTE_SHADER => "COMPUTE_SHADER",
                    &Self::COMPUTE_SHADER_KHR => "COMPUTE_SHADER_KHR",
                    &Self::ALL_TRANSFER => "ALL_TRANSFER",
                    &Self::ALL_TRANSFER_KHR => "ALL_TRANSFER_KHR",
                    &Self::TRANSFER => "TRANSFER",
                    &Self::TRANSFER_KHR => "TRANSFER_KHR",
                    &Self::BOTTOM_OF_PIPE => "BOTTOM_OF_PIPE",
                    &Self::BOTTOM_OF_PIPE_KHR => "BOTTOM_OF_PIPE_KHR",
                    &Self::HOST => "HOST",
                    &Self::HOST_KHR => "HOST_KHR",
                    &Self::ALL_GRAPHICS => "ALL_GRAPHICS",
                    &Self::ALL_GRAPHICS_KHR => "ALL_GRAPHICS_KHR",
                    &Self::ALL_COMMANDS => "ALL_COMMANDS",
                    &Self::ALL_COMMANDS_KHR => "ALL_COMMANDS_KHR",
                    &Self::COPY => "COPY",
                    &Self::COPY_KHR => "COPY_KHR",
                    &Self::RESOLVE => "RESOLVE",
                    &Self::RESOLVE_KHR => "RESOLVE_KHR",
                    &Self::BLIT => "BLIT",
                    &Self::BLIT_KHR => "BLIT_KHR",
                    &Self::CLEAR => "CLEAR",
                    &Self::CLEAR_KHR => "CLEAR_KHR",
                    &Self::INDEX_INPUT => "INDEX_INPUT",
                    &Self::INDEX_INPUT_KHR => "INDEX_INPUT_KHR",
                    &Self::VERTEX_ATTRIBUTE_INPUT => "VERTEX_ATTRIBUTE_INPUT",
                    &Self::VERTEX_ATTRIBUTE_INPUT_KHR => "VERTEX_ATTRIBUTE_INPUT_KHR",
                    &Self::PRE_RASTERIZATION_SHADERS => "PRE_RASTERIZATION_SHADERS",
                    &Self::PRE_RASTERIZATION_SHADERS_KHR => {
                        "PRE_RASTERIZATION_SHADERS_KHR"
                    }
                    &Self::VIDEO_DECODE_KHR => "VIDEO_DECODE_KHR",
                    &Self::VIDEO_ENCODE_KHR => "VIDEO_ENCODE_KHR",
                    &Self::TRANSFORM_FEEDBACK_EXT => "TRANSFORM_FEEDBACK_EXT",
                    &Self::CONDITIONAL_RENDERING_EXT => "CONDITIONAL_RENDERING_EXT",
                    &Self::COMMAND_PREPROCESS_NV => "COMMAND_PREPROCESS_NV",
                    &Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR => {
                        "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"
                    }
                    &Self::SHADING_RATE_IMAGE_NV => "SHADING_RATE_IMAGE_NV",
                    &Self::ACCELERATION_STRUCTURE_BUILD_KHR => {
                        "ACCELERATION_STRUCTURE_BUILD_KHR"
                    }
                    &Self::RAY_TRACING_SHADER_KHR => "RAY_TRACING_SHADER_KHR",
                    &Self::RAY_TRACING_SHADER_NV => "RAY_TRACING_SHADER_NV",
                    &Self::ACCELERATION_STRUCTURE_BUILD_NV => {
                        "ACCELERATION_STRUCTURE_BUILD_NV"
                    }
                    &Self::FRAGMENT_DENSITY_PROCESS_EXT => "FRAGMENT_DENSITY_PROCESS_EXT",
                    &Self::TASK_SHADER_NV => "TASK_SHADER_NV",
                    &Self::MESH_SHADER_NV => "MESH_SHADER_NV",
                    &Self::SUBPASS_SHADING_HUAWEI => "SUBPASS_SHADING_HUAWEI",
                    &Self::INVOCATION_MASK_HUAWEI => "INVOCATION_MASK_HUAWEI",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::PipelineStageFlagBits2 {
    pub const NONE: Self = Self(0);
    pub const NONE_KHR: Self = Self(0);
    pub const TOP_OF_PIPE: Self = Self(1);
    pub const TOP_OF_PIPE_KHR: Self = Self(1);
    pub const DRAW_INDIRECT: Self = Self(2);
    pub const DRAW_INDIRECT_KHR: Self = Self(2);
    pub const VERTEX_INPUT: Self = Self(4);
    pub const VERTEX_INPUT_KHR: Self = Self(4);
    pub const VERTEX_SHADER: Self = Self(8);
    pub const VERTEX_SHADER_KHR: Self = Self(8);
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(16);
    pub const TESSELLATION_CONTROL_SHADER_KHR: Self = Self(16);
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    pub const TESSELLATION_EVALUATION_SHADER_KHR: Self = Self(32);
    pub const GEOMETRY_SHADER: Self = Self(64);
    pub const GEOMETRY_SHADER_KHR: Self = Self(64);
    pub const FRAGMENT_SHADER: Self = Self(128);
    pub const FRAGMENT_SHADER_KHR: Self = Self(128);
    pub const EARLY_FRAGMENT_TESTS: Self = Self(256);
    pub const EARLY_FRAGMENT_TESTS_KHR: Self = Self(256);
    pub const LATE_FRAGMENT_TESTS: Self = Self(512);
    pub const LATE_FRAGMENT_TESTS_KHR: Self = Self(512);
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    pub const COLOR_ATTACHMENT_OUTPUT_KHR: Self = Self(1024);
    pub const COMPUTE_SHADER: Self = Self(2048);
    pub const COMPUTE_SHADER_KHR: Self = Self(2048);
    pub const ALL_TRANSFER: Self = Self(4096);
    pub const ALL_TRANSFER_KHR: Self = Self(4096);
    pub const TRANSFER: Self = Self(4096);
    pub const TRANSFER_KHR: Self = Self(4096);
    pub const BOTTOM_OF_PIPE: Self = Self(8192);
    pub const BOTTOM_OF_PIPE_KHR: Self = Self(8192);
    pub const HOST: Self = Self(16384);
    pub const HOST_KHR: Self = Self(16384);
    pub const ALL_GRAPHICS: Self = Self(32768);
    pub const ALL_GRAPHICS_KHR: Self = Self(32768);
    pub const ALL_COMMANDS: Self = Self(65536);
    pub const ALL_COMMANDS_KHR: Self = Self(65536);
    pub const COPY: Self = Self(4294967296);
    pub const COPY_KHR: Self = Self(4294967296);
    pub const RESOLVE: Self = Self(8589934592);
    pub const RESOLVE_KHR: Self = Self(8589934592);
    pub const BLIT: Self = Self(17179869184);
    pub const BLIT_KHR: Self = Self(17179869184);
    pub const CLEAR: Self = Self(34359738368);
    pub const CLEAR_KHR: Self = Self(34359738368);
    pub const INDEX_INPUT: Self = Self(68719476736);
    pub const INDEX_INPUT_KHR: Self = Self(68719476736);
    pub const VERTEX_ATTRIBUTE_INPUT: Self = Self(137438953472);
    pub const VERTEX_ATTRIBUTE_INPUT_KHR: Self = Self(137438953472);
    pub const PRE_RASTERIZATION_SHADERS: Self = Self(274877906944);
    pub const PRE_RASTERIZATION_SHADERS_KHR: Self = Self(274877906944);
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags2.html) · Bitmask of [`FormatFeatureFlagBits2`]"]
    #[doc(alias = "VkFormatFeatureFlags2")] #[derive(Default)] #[repr(transparent)] pub
    struct FormatFeatureFlags2 : u64 { const SAMPLED_IMAGE =
    FormatFeatureFlagBits2::SAMPLED_IMAGE.0; const SAMPLED_IMAGE_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_KHR.0; const STORAGE_IMAGE =
    FormatFeatureFlagBits2::STORAGE_IMAGE.0; const STORAGE_IMAGE_KHR =
    FormatFeatureFlagBits2::STORAGE_IMAGE_KHR.0; const STORAGE_IMAGE_ATOMIC =
    FormatFeatureFlagBits2::STORAGE_IMAGE_ATOMIC.0; const STORAGE_IMAGE_ATOMIC_KHR =
    FormatFeatureFlagBits2::STORAGE_IMAGE_ATOMIC_KHR.0; const UNIFORM_TEXEL_BUFFER =
    FormatFeatureFlagBits2::UNIFORM_TEXEL_BUFFER.0; const UNIFORM_TEXEL_BUFFER_KHR =
    FormatFeatureFlagBits2::UNIFORM_TEXEL_BUFFER_KHR.0; const STORAGE_TEXEL_BUFFER =
    FormatFeatureFlagBits2::STORAGE_TEXEL_BUFFER.0; const STORAGE_TEXEL_BUFFER_KHR =
    FormatFeatureFlagBits2::STORAGE_TEXEL_BUFFER_KHR.0; const STORAGE_TEXEL_BUFFER_ATOMIC
    = FormatFeatureFlagBits2::STORAGE_TEXEL_BUFFER_ATOMIC.0; const
    STORAGE_TEXEL_BUFFER_ATOMIC_KHR =
    FormatFeatureFlagBits2::STORAGE_TEXEL_BUFFER_ATOMIC_KHR.0; const VERTEX_BUFFER =
    FormatFeatureFlagBits2::VERTEX_BUFFER.0; const VERTEX_BUFFER_KHR =
    FormatFeatureFlagBits2::VERTEX_BUFFER_KHR.0; const COLOR_ATTACHMENT =
    FormatFeatureFlagBits2::COLOR_ATTACHMENT.0; const COLOR_ATTACHMENT_KHR =
    FormatFeatureFlagBits2::COLOR_ATTACHMENT_KHR.0; const COLOR_ATTACHMENT_BLEND =
    FormatFeatureFlagBits2::COLOR_ATTACHMENT_BLEND.0; const COLOR_ATTACHMENT_BLEND_KHR =
    FormatFeatureFlagBits2::COLOR_ATTACHMENT_BLEND_KHR.0; const DEPTH_STENCIL_ATTACHMENT
    = FormatFeatureFlagBits2::DEPTH_STENCIL_ATTACHMENT.0; const
    DEPTH_STENCIL_ATTACHMENT_KHR =
    FormatFeatureFlagBits2::DEPTH_STENCIL_ATTACHMENT_KHR.0; const BLIT_SRC =
    FormatFeatureFlagBits2::BLIT_SRC.0; const BLIT_SRC_KHR =
    FormatFeatureFlagBits2::BLIT_SRC_KHR.0; const BLIT_DST =
    FormatFeatureFlagBits2::BLIT_DST.0; const BLIT_DST_KHR =
    FormatFeatureFlagBits2::BLIT_DST_KHR.0; const SAMPLED_IMAGE_FILTER_LINEAR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_LINEAR.0; const
    SAMPLED_IMAGE_FILTER_LINEAR_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_LINEAR_KHR.0; const
    SAMPLED_IMAGE_FILTER_CUBIC = FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_CUBIC.0;
    const SAMPLED_IMAGE_FILTER_CUBIC_EXT =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_CUBIC_EXT.0; const TRANSFER_SRC =
    FormatFeatureFlagBits2::TRANSFER_SRC.0; const TRANSFER_SRC_KHR =
    FormatFeatureFlagBits2::TRANSFER_SRC_KHR.0; const TRANSFER_DST =
    FormatFeatureFlagBits2::TRANSFER_DST.0; const TRANSFER_DST_KHR =
    FormatFeatureFlagBits2::TRANSFER_DST_KHR.0; const SAMPLED_IMAGE_FILTER_MINMAX =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_MINMAX.0; const
    SAMPLED_IMAGE_FILTER_MINMAX_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_FILTER_MINMAX_KHR.0; const
    MIDPOINT_CHROMA_SAMPLES = FormatFeatureFlagBits2::MIDPOINT_CHROMA_SAMPLES.0; const
    MIDPOINT_CHROMA_SAMPLES_KHR = FormatFeatureFlagBits2::MIDPOINT_CHROMA_SAMPLES_KHR.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER.0; const
    SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR.0; const
    SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE.0;
    const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR.0;
    const DISJOINT = FormatFeatureFlagBits2::DISJOINT.0; const DISJOINT_KHR =
    FormatFeatureFlagBits2::DISJOINT_KHR.0; const COSITED_CHROMA_SAMPLES =
    FormatFeatureFlagBits2::COSITED_CHROMA_SAMPLES.0; const COSITED_CHROMA_SAMPLES_KHR =
    FormatFeatureFlagBits2::COSITED_CHROMA_SAMPLES_KHR.0; const
    STORAGE_READ_WITHOUT_FORMAT = FormatFeatureFlagBits2::STORAGE_READ_WITHOUT_FORMAT.0;
    const STORAGE_READ_WITHOUT_FORMAT_KHR =
    FormatFeatureFlagBits2::STORAGE_READ_WITHOUT_FORMAT_KHR.0; const
    STORAGE_WRITE_WITHOUT_FORMAT =
    FormatFeatureFlagBits2::STORAGE_WRITE_WITHOUT_FORMAT.0; const
    STORAGE_WRITE_WITHOUT_FORMAT_KHR =
    FormatFeatureFlagBits2::STORAGE_WRITE_WITHOUT_FORMAT_KHR.0; const
    SAMPLED_IMAGE_DEPTH_COMPARISON =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_DEPTH_COMPARISON.0; const
    SAMPLED_IMAGE_DEPTH_COMPARISON_KHR =
    FormatFeatureFlagBits2::SAMPLED_IMAGE_DEPTH_COMPARISON_KHR.0; const
    VIDEO_DECODE_OUTPUT_KHR = FormatFeatureFlagBits2::VIDEO_DECODE_OUTPUT_KHR.0; const
    VIDEO_DECODE_DPB_KHR = FormatFeatureFlagBits2::VIDEO_DECODE_DPB_KHR.0; const
    ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR =
    FormatFeatureFlagBits2::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR.0; const
    FRAGMENT_DENSITY_MAP_EXT = FormatFeatureFlagBits2::FRAGMENT_DENSITY_MAP_EXT.0; const
    FRAGMENT_SHADING_RATE_ATTACHMENT_KHR =
    FormatFeatureFlagBits2::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.0; const
    VIDEO_ENCODE_INPUT_KHR = FormatFeatureFlagBits2::VIDEO_ENCODE_INPUT_KHR.0; const
    VIDEO_ENCODE_DPB_KHR = FormatFeatureFlagBits2::VIDEO_ENCODE_DPB_KHR.0; const
    LINEAR_COLOR_ATTACHMENT_NV = FormatFeatureFlagBits2::LINEAR_COLOR_ATTACHMENT_NV.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2.html) · Bits enum of [`FormatFeatureFlags2`]
#[doc(alias = "VkFormatFeatureFlagBits2")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct FormatFeatureFlagBits2(pub u64);
impl FormatFeatureFlagBits2 {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> FormatFeatureFlags2 {
        FormatFeatureFlags2::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for FormatFeatureFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::SAMPLED_IMAGE => "SAMPLED_IMAGE",
                    &Self::SAMPLED_IMAGE_KHR => "SAMPLED_IMAGE_KHR",
                    &Self::STORAGE_IMAGE => "STORAGE_IMAGE",
                    &Self::STORAGE_IMAGE_KHR => "STORAGE_IMAGE_KHR",
                    &Self::STORAGE_IMAGE_ATOMIC => "STORAGE_IMAGE_ATOMIC",
                    &Self::STORAGE_IMAGE_ATOMIC_KHR => "STORAGE_IMAGE_ATOMIC_KHR",
                    &Self::UNIFORM_TEXEL_BUFFER => "UNIFORM_TEXEL_BUFFER",
                    &Self::UNIFORM_TEXEL_BUFFER_KHR => "UNIFORM_TEXEL_BUFFER_KHR",
                    &Self::STORAGE_TEXEL_BUFFER => "STORAGE_TEXEL_BUFFER",
                    &Self::STORAGE_TEXEL_BUFFER_KHR => "STORAGE_TEXEL_BUFFER_KHR",
                    &Self::STORAGE_TEXEL_BUFFER_ATOMIC => "STORAGE_TEXEL_BUFFER_ATOMIC",
                    &Self::STORAGE_TEXEL_BUFFER_ATOMIC_KHR => {
                        "STORAGE_TEXEL_BUFFER_ATOMIC_KHR"
                    }
                    &Self::VERTEX_BUFFER => "VERTEX_BUFFER",
                    &Self::VERTEX_BUFFER_KHR => "VERTEX_BUFFER_KHR",
                    &Self::COLOR_ATTACHMENT => "COLOR_ATTACHMENT",
                    &Self::COLOR_ATTACHMENT_KHR => "COLOR_ATTACHMENT_KHR",
                    &Self::COLOR_ATTACHMENT_BLEND => "COLOR_ATTACHMENT_BLEND",
                    &Self::COLOR_ATTACHMENT_BLEND_KHR => "COLOR_ATTACHMENT_BLEND_KHR",
                    &Self::DEPTH_STENCIL_ATTACHMENT => "DEPTH_STENCIL_ATTACHMENT",
                    &Self::DEPTH_STENCIL_ATTACHMENT_KHR => "DEPTH_STENCIL_ATTACHMENT_KHR",
                    &Self::BLIT_SRC => "BLIT_SRC",
                    &Self::BLIT_SRC_KHR => "BLIT_SRC_KHR",
                    &Self::BLIT_DST => "BLIT_DST",
                    &Self::BLIT_DST_KHR => "BLIT_DST_KHR",
                    &Self::SAMPLED_IMAGE_FILTER_LINEAR => "SAMPLED_IMAGE_FILTER_LINEAR",
                    &Self::SAMPLED_IMAGE_FILTER_LINEAR_KHR => {
                        "SAMPLED_IMAGE_FILTER_LINEAR_KHR"
                    }
                    &Self::SAMPLED_IMAGE_FILTER_CUBIC => "SAMPLED_IMAGE_FILTER_CUBIC",
                    &Self::SAMPLED_IMAGE_FILTER_CUBIC_EXT => {
                        "SAMPLED_IMAGE_FILTER_CUBIC_EXT"
                    }
                    &Self::TRANSFER_SRC => "TRANSFER_SRC",
                    &Self::TRANSFER_SRC_KHR => "TRANSFER_SRC_KHR",
                    &Self::TRANSFER_DST => "TRANSFER_DST",
                    &Self::TRANSFER_DST_KHR => "TRANSFER_DST_KHR",
                    &Self::SAMPLED_IMAGE_FILTER_MINMAX => "SAMPLED_IMAGE_FILTER_MINMAX",
                    &Self::SAMPLED_IMAGE_FILTER_MINMAX_KHR => {
                        "SAMPLED_IMAGE_FILTER_MINMAX_KHR"
                    }
                    &Self::MIDPOINT_CHROMA_SAMPLES => "MIDPOINT_CHROMA_SAMPLES",
                    &Self::MIDPOINT_CHROMA_SAMPLES_KHR => "MIDPOINT_CHROMA_SAMPLES_KHR",
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE"
                    }
                    &Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR => {
                        "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR"
                    }
                    &Self::DISJOINT => "DISJOINT",
                    &Self::DISJOINT_KHR => "DISJOINT_KHR",
                    &Self::COSITED_CHROMA_SAMPLES => "COSITED_CHROMA_SAMPLES",
                    &Self::COSITED_CHROMA_SAMPLES_KHR => "COSITED_CHROMA_SAMPLES_KHR",
                    &Self::STORAGE_READ_WITHOUT_FORMAT => "STORAGE_READ_WITHOUT_FORMAT",
                    &Self::STORAGE_READ_WITHOUT_FORMAT_KHR => {
                        "STORAGE_READ_WITHOUT_FORMAT_KHR"
                    }
                    &Self::STORAGE_WRITE_WITHOUT_FORMAT => "STORAGE_WRITE_WITHOUT_FORMAT",
                    &Self::STORAGE_WRITE_WITHOUT_FORMAT_KHR => {
                        "STORAGE_WRITE_WITHOUT_FORMAT_KHR"
                    }
                    &Self::SAMPLED_IMAGE_DEPTH_COMPARISON => {
                        "SAMPLED_IMAGE_DEPTH_COMPARISON"
                    }
                    &Self::SAMPLED_IMAGE_DEPTH_COMPARISON_KHR => {
                        "SAMPLED_IMAGE_DEPTH_COMPARISON_KHR"
                    }
                    &Self::VIDEO_DECODE_OUTPUT_KHR => "VIDEO_DECODE_OUTPUT_KHR",
                    &Self::VIDEO_DECODE_DPB_KHR => "VIDEO_DECODE_DPB_KHR",
                    &Self::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR => {
                        "ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR"
                    }
                    &Self::FRAGMENT_DENSITY_MAP_EXT => "FRAGMENT_DENSITY_MAP_EXT",
                    &Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR => {
                        "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"
                    }
                    &Self::VIDEO_ENCODE_INPUT_KHR => "VIDEO_ENCODE_INPUT_KHR",
                    &Self::VIDEO_ENCODE_DPB_KHR => "VIDEO_ENCODE_DPB_KHR",
                    &Self::LINEAR_COLOR_ATTACHMENT_NV => "LINEAR_COLOR_ATTACHMENT_NV",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::FormatFeatureFlagBits2 {
    pub const SAMPLED_IMAGE: Self = Self(1);
    pub const SAMPLED_IMAGE_KHR: Self = Self(1);
    pub const STORAGE_IMAGE: Self = Self(2);
    pub const STORAGE_IMAGE_KHR: Self = Self(2);
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(4);
    pub const STORAGE_IMAGE_ATOMIC_KHR: Self = Self(4);
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(8);
    pub const UNIFORM_TEXEL_BUFFER_KHR: Self = Self(8);
    pub const STORAGE_TEXEL_BUFFER: Self = Self(16);
    pub const STORAGE_TEXEL_BUFFER_KHR: Self = Self(16);
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    pub const STORAGE_TEXEL_BUFFER_ATOMIC_KHR: Self = Self(32);
    pub const VERTEX_BUFFER: Self = Self(64);
    pub const VERTEX_BUFFER_KHR: Self = Self(64);
    pub const COLOR_ATTACHMENT: Self = Self(128);
    pub const COLOR_ATTACHMENT_KHR: Self = Self(128);
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(256);
    pub const COLOR_ATTACHMENT_BLEND_KHR: Self = Self(256);
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    pub const DEPTH_STENCIL_ATTACHMENT_KHR: Self = Self(512);
    pub const BLIT_SRC: Self = Self(1024);
    pub const BLIT_SRC_KHR: Self = Self(1024);
    pub const BLIT_DST: Self = Self(2048);
    pub const BLIT_DST_KHR: Self = Self(2048);
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    pub const SAMPLED_IMAGE_FILTER_LINEAR_KHR: Self = Self(4096);
    pub const SAMPLED_IMAGE_FILTER_CUBIC: Self = Self(8192);
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self(8192);
    pub const TRANSFER_SRC: Self = Self(16384);
    pub const TRANSFER_SRC_KHR: Self = Self(16384);
    pub const TRANSFER_DST: Self = Self(32768);
    pub const TRANSFER_DST_KHR: Self = Self(32768);
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    pub const SAMPLED_IMAGE_FILTER_MINMAX_KHR: Self = Self(65536);
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self(131072);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self = Self(262144);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(
        524288,
    );
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self = Self(
        524288,
    );
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(
        1048576,
    );
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self = Self(
        1048576,
    );
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(
        2097152,
    );
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self = Self(
        2097152,
    );
    pub const DISJOINT: Self = Self(4194304);
    pub const DISJOINT_KHR: Self = Self(4194304);
    pub const COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self(8388608);
    pub const STORAGE_READ_WITHOUT_FORMAT: Self = Self(2147483648);
    pub const STORAGE_READ_WITHOUT_FORMAT_KHR: Self = Self(2147483648);
    pub const STORAGE_WRITE_WITHOUT_FORMAT: Self = Self(4294967296);
    pub const STORAGE_WRITE_WITHOUT_FORMAT_KHR: Self = Self(4294967296);
    pub const SAMPLED_IMAGE_DEPTH_COMPARISON: Self = Self(8589934592);
    pub const SAMPLED_IMAGE_DEPTH_COMPARISON_KHR: Self = Self(8589934592);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::AttachmentStoreOp {
    pub const NONE: Self = Self(1000301000);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::PipelineCacheCreateFlagBits {
    pub const EXTERNALLY_SYNCHRONIZED: Self = Self(1);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::PipelineShaderStageCreateFlagBits {
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(1);
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(2);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::DescriptorType {
    pub const INLINE_UNIFORM_BLOCK: Self = Self(1000138000);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::DynamicState {
    pub const CULL_MODE: Self = Self(1000267000);
    pub const FRONT_FACE: Self = Self(1000267001);
    pub const PRIMITIVE_TOPOLOGY: Self = Self(1000267002);
    pub const VIEWPORT_WITH_COUNT: Self = Self(1000267003);
    pub const SCISSOR_WITH_COUNT: Self = Self(1000267004);
    pub const VERTEX_INPUT_BINDING_STRIDE: Self = Self(1000267005);
    pub const DEPTH_TEST_ENABLE: Self = Self(1000267006);
    pub const DEPTH_WRITE_ENABLE: Self = Self(1000267007);
    pub const DEPTH_COMPARE_OP: Self = Self(1000267008);
    pub const DEPTH_BOUNDS_TEST_ENABLE: Self = Self(1000267009);
    pub const STENCIL_TEST_ENABLE: Self = Self(1000267010);
    pub const STENCIL_OP: Self = Self(1000267011);
    pub const RASTERIZER_DISCARD_ENABLE: Self = Self(1000377001);
    pub const DEPTH_BIAS_ENABLE: Self = Self(1000377002);
    pub const PRIMITIVE_RESTART_ENABLE: Self = Self(1000377004);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::Format {
    pub const G8_B8R8_2PLANE_444_UNORM: Self = Self(1000330000);
    pub const G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: Self = Self(1000330001);
    pub const G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: Self = Self(1000330002);
    pub const G16_B16R16_2PLANE_444_UNORM: Self = Self(1000330003);
    pub const A4R4G4B4_UNORM_PACK16: Self = Self(1000340000);
    pub const A4B4G4R4_UNORM_PACK16: Self = Self(1000340001);
    pub const ASTC_4X4_SFLOAT_BLOCK: Self = Self(1000066000);
    pub const ASTC_5X4_SFLOAT_BLOCK: Self = Self(1000066001);
    pub const ASTC_5X5_SFLOAT_BLOCK: Self = Self(1000066002);
    pub const ASTC_6X5_SFLOAT_BLOCK: Self = Self(1000066003);
    pub const ASTC_6X6_SFLOAT_BLOCK: Self = Self(1000066004);
    pub const ASTC_8X5_SFLOAT_BLOCK: Self = Self(1000066005);
    pub const ASTC_8X6_SFLOAT_BLOCK: Self = Self(1000066006);
    pub const ASTC_8X8_SFLOAT_BLOCK: Self = Self(1000066007);
    pub const ASTC_10X5_SFLOAT_BLOCK: Self = Self(1000066008);
    pub const ASTC_10X6_SFLOAT_BLOCK: Self = Self(1000066009);
    pub const ASTC_10X8_SFLOAT_BLOCK: Self = Self(1000066010);
    pub const ASTC_10X10_SFLOAT_BLOCK: Self = Self(1000066011);
    pub const ASTC_12X10_SFLOAT_BLOCK: Self = Self(1000066012);
    pub const ASTC_12X12_SFLOAT_BLOCK: Self = Self(1000066013);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::ImageAspectFlagBits {
    pub const NONE: Self = Self(0);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::ImageLayout {
    pub const READ_ONLY_OPTIMAL: Self = Self(1000314000);
    pub const ATTACHMENT_OPTIMAL: Self = Self(1000314001);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::AccessFlagBits {
    pub const NONE: Self = Self(0);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::PipelineCreateFlagBits {
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(256);
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(512);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::Result {
    pub const PIPELINE_COMPILE_REQUIRED: Self = Self(1000297000);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::StructureType {
    pub const PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: Self = Self(53);
    pub const PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: Self = Self(54);
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO: Self = Self(1000192000);
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: Self = Self(
        1000215000,
    );
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES: Self = Self(1000245000);
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: Self = Self(
        1000276000,
    );
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: Self = Self(1000295000);
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO: Self = Self(1000295001);
    pub const PRIVATE_DATA_SLOT_CREATE_INFO: Self = Self(1000295002);
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: Self = Self(
        1000297000,
    );
    pub const MEMORY_BARRIER_2: Self = Self(1000314000);
    pub const BUFFER_MEMORY_BARRIER_2: Self = Self(1000314001);
    pub const IMAGE_MEMORY_BARRIER_2: Self = Self(1000314002);
    pub const DEPENDENCY_INFO: Self = Self(1000314003);
    pub const SUBMIT_INFO_2: Self = Self(1000314004);
    pub const SEMAPHORE_SUBMIT_INFO: Self = Self(1000314005);
    pub const COMMAND_BUFFER_SUBMIT_INFO: Self = Self(1000314006);
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: Self = Self(1000314007);
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: Self = Self(
        1000325000,
    );
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: Self = Self(1000335000);
    pub const COPY_BUFFER_INFO_2: Self = Self(1000337000);
    pub const COPY_IMAGE_INFO_2: Self = Self(1000337001);
    pub const COPY_BUFFER_TO_IMAGE_INFO_2: Self = Self(1000337002);
    pub const COPY_IMAGE_TO_BUFFER_INFO_2: Self = Self(1000337003);
    pub const BLIT_IMAGE_INFO_2: Self = Self(1000337004);
    pub const RESOLVE_IMAGE_INFO_2: Self = Self(1000337005);
    pub const BUFFER_COPY_2: Self = Self(1000337006);
    pub const IMAGE_COPY_2: Self = Self(1000337007);
    pub const IMAGE_BLIT_2: Self = Self(1000337008);
    pub const BUFFER_IMAGE_COPY_2: Self = Self(1000337009);
    pub const IMAGE_RESOLVE_2: Self = Self(1000337010);
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: Self = Self(1000225000);
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: Self = Self(
        1000225001,
    );
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: Self = Self(1000225002);
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: Self = Self(1000138000);
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: Self = Self(1000138001);
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: Self = Self(1000138002);
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: Self = Self(1000138003);
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: Self = Self(
        1000066000,
    );
    pub const RENDERING_INFO: Self = Self(1000044000);
    pub const RENDERING_ATTACHMENT_INFO: Self = Self(1000044001);
    pub const PIPELINE_RENDERING_CREATE_INFO: Self = Self(1000044002);
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: Self = Self(1000044003);
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: Self = Self(1000044004);
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: Self = Self(
        1000280000,
    );
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: Self = Self(
        1000280001,
    );
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: Self = Self(1000281001);
    pub const FORMAT_PROPERTIES_3: Self = Self(1000360000);
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: Self = Self(1000413000);
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: Self = Self(1000413001);
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS: Self = Self(1000413002);
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS: Self = Self(1000413003);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::PipelineStageFlagBits {
    pub const NONE: Self = Self(0);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::ObjectType {
    pub const PRIVATE_DATA_SLOT: Self = Self(1000295000);
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_0::EventCreateFlagBits {
    pub const DEVICE_ONLY: Self = Self(1);
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateFlags.html) · Bitmask of [`PrivateDataSlotCreateFlagBits`]"]
    #[doc(alias = "VkPrivateDataSlotCreateFlags")] #[derive(Default)]
    #[repr(transparent)] pub struct PrivateDataSlotCreateFlags : u32 {
    #[cfg(empty_bitflag_workaround)] const EMPTY_BITFLAG_WORKAROUND = 0; }
}
///<s>Vulkan Manual Page</s> · Bits enum of [`PrivateDataSlotCreateFlags`]
#[doc(alias = "VkPrivateDataSlotCreateFlagBits")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct PrivateDataSlotCreateFlagBits(pub u32);
impl PrivateDataSlotCreateFlagBits {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> PrivateDataSlotCreateFlags {
        PrivateDataSlotCreateFlags::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for PrivateDataSlotCreateFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    _ => "(unknown variant)",
                },
            )
    }
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlags.html) · Bitmask of [`PipelineCreationFeedbackFlagBits`]"]
    #[doc(alias = "VkPipelineCreationFeedbackFlags")] #[derive(Default)]
    #[repr(transparent)] pub struct PipelineCreationFeedbackFlags : u32 { const VALID =
    PipelineCreationFeedbackFlagBits::VALID.0; const APPLICATION_PIPELINE_CACHE_HIT =
    PipelineCreationFeedbackFlagBits::APPLICATION_PIPELINE_CACHE_HIT.0; const
    BASE_PIPELINE_ACCELERATION =
    PipelineCreationFeedbackFlagBits::BASE_PIPELINE_ACCELERATION.0; const VALID_EXT =
    PipelineCreationFeedbackFlagBits::VALID_EXT.0; const
    APPLICATION_PIPELINE_CACHE_HIT_EXT =
    PipelineCreationFeedbackFlagBits::APPLICATION_PIPELINE_CACHE_HIT_EXT.0; const
    BASE_PIPELINE_ACCELERATION_EXT =
    PipelineCreationFeedbackFlagBits::BASE_PIPELINE_ACCELERATION_EXT.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlagBits.html) · Bits enum of [`PipelineCreationFeedbackFlags`]
#[doc(alias = "VkPipelineCreationFeedbackFlagBits")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct PipelineCreationFeedbackFlagBits(pub u32);
impl PipelineCreationFeedbackFlagBits {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> PipelineCreationFeedbackFlags {
        PipelineCreationFeedbackFlags::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for PipelineCreationFeedbackFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::VALID => "VALID",
                    &Self::APPLICATION_PIPELINE_CACHE_HIT => {
                        "APPLICATION_PIPELINE_CACHE_HIT"
                    }
                    &Self::BASE_PIPELINE_ACCELERATION => "BASE_PIPELINE_ACCELERATION",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::PipelineCreationFeedbackFlagBits {
    pub const VALID: Self = Self(1);
    pub const APPLICATION_PIPELINE_CACHE_HIT: Self = Self(2);
    pub const BASE_PIPELINE_ACCELERATION: Self = Self(4);
    pub const VALID_EXT: Self = Self::VALID;
    pub const APPLICATION_PIPELINE_CACHE_HIT_EXT: Self = Self::APPLICATION_PIPELINE_CACHE_HIT;
    pub const BASE_PIPELINE_ACCELERATION_EXT: Self = Self::BASE_PIPELINE_ACCELERATION;
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlags.html) · Bitmask of [`ToolPurposeFlagBits`]"]
    #[doc(alias = "VkToolPurposeFlags")] #[derive(Default)] #[repr(transparent)] pub
    struct ToolPurposeFlags : u32 { const VALIDATION = ToolPurposeFlagBits::VALIDATION.0;
    const PROFILING = ToolPurposeFlagBits::PROFILING.0; const TRACING =
    ToolPurposeFlagBits::TRACING.0; const ADDITIONAL_FEATURES =
    ToolPurposeFlagBits::ADDITIONAL_FEATURES.0; const MODIFYING_FEATURES =
    ToolPurposeFlagBits::MODIFYING_FEATURES.0; const DEBUG_REPORTING_EXT =
    ToolPurposeFlagBits::DEBUG_REPORTING_EXT.0; const DEBUG_MARKERS_EXT =
    ToolPurposeFlagBits::DEBUG_MARKERS_EXT.0; const VALIDATION_EXT =
    ToolPurposeFlagBits::VALIDATION_EXT.0; const PROFILING_EXT =
    ToolPurposeFlagBits::PROFILING_EXT.0; const TRACING_EXT =
    ToolPurposeFlagBits::TRACING_EXT.0; const ADDITIONAL_FEATURES_EXT =
    ToolPurposeFlagBits::ADDITIONAL_FEATURES_EXT.0; const MODIFYING_FEATURES_EXT =
    ToolPurposeFlagBits::MODIFYING_FEATURES_EXT.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlagBits.html) · Bits enum of [`ToolPurposeFlags`]
#[doc(alias = "VkToolPurposeFlagBits")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct ToolPurposeFlagBits(pub u32);
impl ToolPurposeFlagBits {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> ToolPurposeFlags {
        ToolPurposeFlags::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for ToolPurposeFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::VALIDATION => "VALIDATION",
                    &Self::PROFILING => "PROFILING",
                    &Self::TRACING => "TRACING",
                    &Self::ADDITIONAL_FEATURES => "ADDITIONAL_FEATURES",
                    &Self::MODIFYING_FEATURES => "MODIFYING_FEATURES",
                    &Self::DEBUG_REPORTING_EXT => "DEBUG_REPORTING_EXT",
                    &Self::DEBUG_MARKERS_EXT => "DEBUG_MARKERS_EXT",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::ToolPurposeFlagBits {
    pub const VALIDATION: Self = Self(1);
    pub const PROFILING: Self = Self(2);
    pub const TRACING: Self = Self(4);
    pub const ADDITIONAL_FEATURES: Self = Self(8);
    pub const MODIFYING_FEATURES: Self = Self(16);
    pub const VALIDATION_EXT: Self = Self::VALIDATION;
    pub const PROFILING_EXT: Self = Self::PROFILING;
    pub const TRACING_EXT: Self = Self::TRACING;
    pub const ADDITIONAL_FEATURES_EXT: Self = Self::ADDITIONAL_FEATURES;
    pub const MODIFYING_FEATURES_EXT: Self = Self::MODIFYING_FEATURES;
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlags.html) · Bitmask of [`RenderingFlagBits`]"]
    #[doc(alias = "VkRenderingFlags")] #[derive(Default)] #[repr(transparent)] pub struct
    RenderingFlags : u32 { const CONTENTS_SECONDARY_COMMAND_BUFFERS =
    RenderingFlagBits::CONTENTS_SECONDARY_COMMAND_BUFFERS.0; const SUSPENDING =
    RenderingFlagBits::SUSPENDING.0; const RESUMING = RenderingFlagBits::RESUMING.0;
    const CONTENTS_SECONDARY_COMMAND_BUFFERS_KHR =
    RenderingFlagBits::CONTENTS_SECONDARY_COMMAND_BUFFERS_KHR.0; const SUSPENDING_KHR =
    RenderingFlagBits::SUSPENDING_KHR.0; const RESUMING_KHR =
    RenderingFlagBits::RESUMING_KHR.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlagBits.html) · Bits enum of [`RenderingFlags`]
#[doc(alias = "VkRenderingFlagBits")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct RenderingFlagBits(pub u32);
impl RenderingFlagBits {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> RenderingFlags {
        RenderingFlags::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for RenderingFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::CONTENTS_SECONDARY_COMMAND_BUFFERS => {
                        "CONTENTS_SECONDARY_COMMAND_BUFFERS"
                    }
                    &Self::SUSPENDING => "SUSPENDING",
                    &Self::RESUMING => "RESUMING",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::RenderingFlagBits {
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS: Self = Self(1);
    pub const SUSPENDING: Self = Self(2);
    pub const RESUMING: Self = Self(4);
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS_KHR: Self = Self::CONTENTS_SECONDARY_COMMAND_BUFFERS;
    pub const SUSPENDING_KHR: Self = Self::SUSPENDING;
    pub const RESUMING_KHR: Self = Self::RESUMING;
}
bitflags::bitflags! {
    #[doc =
    "[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlags.html) · Bitmask of [`SubmitFlagBits`]"]
    #[doc(alias = "VkSubmitFlags")] #[derive(Default)] #[repr(transparent)] pub struct
    SubmitFlags : u32 { const PROTECTED = SubmitFlagBits::PROTECTED.0; const
    PROTECTED_KHR = SubmitFlagBits::PROTECTED_KHR.0; }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlagBits.html) · Bits enum of [`SubmitFlags`]
#[doc(alias = "VkSubmitFlagBits")]
#[derive(Copy, Clone, PartialEq, Eq, Hash, Default, Ord, PartialOrd)]
#[repr(transparent)]
pub struct SubmitFlagBits(pub u32);
impl SubmitFlagBits {
    #[inline]
    ///Converts this enum variant to the corresponding bitmask
    pub const fn bitmask(&self) -> SubmitFlags {
        SubmitFlags::from_bits_truncate(self.0)
    }
}
impl std::fmt::Debug for SubmitFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .write_str(
                match self {
                    &Self::PROTECTED => "PROTECTED",
                    _ => "(unknown variant)",
                },
            )
    }
}
///Provided by [`crate::vk1_3`]
impl crate::vk1_3::SubmitFlagBits {
    pub const PROTECTED: Self = Self(1);
    pub const PROTECTED_KHR: Self = Self::PROTECTED;
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkGetDeviceBufferMemoryRequirements = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    p_info: *const crate::vk1_3::DeviceBufferMemoryRequirements,
    p_memory_requirements: *mut crate::vk1_1::MemoryRequirements2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkGetDeviceImageMemoryRequirements = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    p_info: *const crate::vk1_3::DeviceImageMemoryRequirements,
    p_memory_requirements: *mut crate::vk1_1::MemoryRequirements2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkGetDeviceImageSparseMemoryRequirements = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    p_info: *const crate::vk1_3::DeviceImageMemoryRequirements,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut crate::vk1_1::SparseImageMemoryRequirements2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkGetPhysicalDeviceToolProperties = unsafe extern "system" fn(
    physical_device: crate::vk1_0::PhysicalDevice,
    p_tool_count: *mut u32,
    p_tool_properties: *mut crate::vk1_3::PhysicalDeviceToolProperties,
) -> crate::vk1_0::Result;
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetCullMode = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    cull_mode: crate::vk1_0::CullModeFlags,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetFrontFace = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    front_face: crate::vk1_0::FrontFace,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetPrimitiveTopology = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    primitive_topology: crate::vk1_0::PrimitiveTopology,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetViewportWithCount = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    viewport_count: u32,
    p_viewports: *const crate::vk1_0::Viewport,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetScissorWithCount = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    scissor_count: u32,
    p_scissors: *const crate::vk1_0::Rect2D,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdBindVertexBuffers2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const crate::vk1_0::Buffer,
    p_offsets: *const crate::vk1_0::DeviceSize,
    p_sizes: *const crate::vk1_0::DeviceSize,
    p_strides: *const crate::vk1_0::DeviceSize,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetDepthTestEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    depth_test_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetDepthWriteEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    depth_write_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetDepthCompareOp = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    depth_compare_op: crate::vk1_0::CompareOp,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetDepthBoundsTestEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    depth_bounds_test_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetStencilTestEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    stencil_test_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetStencilOp = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    face_mask: crate::vk1_0::StencilFaceFlags,
    fail_op: crate::vk1_0::StencilOp,
    pass_op: crate::vk1_0::StencilOp,
    depth_fail_op: crate::vk1_0::StencilOp,
    compare_op: crate::vk1_0::CompareOp,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetRasterizerDiscardEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    rasterizer_discard_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetDepthBiasEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    depth_bias_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetPrimitiveRestartEnable = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    primitive_restart_enable: crate::vk1_0::Bool32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCreatePrivateDataSlot = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    p_create_info: *const crate::vk1_3::PrivateDataSlotCreateInfo,
    p_allocator: *const crate::vk1_0::AllocationCallbacks,
    p_private_data_slot: *mut crate::vk1_3::PrivateDataSlot,
) -> crate::vk1_0::Result;
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkDestroyPrivateDataSlot = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    private_data_slot: crate::vk1_3::PrivateDataSlot,
    p_allocator: *const crate::vk1_0::AllocationCallbacks,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkSetPrivateData = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    object_type: crate::vk1_0::ObjectType,
    object_handle: u64,
    private_data_slot: crate::vk1_3::PrivateDataSlot,
    data: u64,
) -> crate::vk1_0::Result;
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkGetPrivateData = unsafe extern "system" fn(
    device: crate::vk1_0::Device,
    object_type: crate::vk1_0::ObjectType,
    object_handle: u64,
    private_data_slot: crate::vk1_3::PrivateDataSlot,
    p_data: *mut u64,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdCopyBuffer2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_copy_buffer_info: *const crate::vk1_3::CopyBufferInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdCopyImage2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_copy_image_info: *const crate::vk1_3::CopyImageInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdBlitImage2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_blit_image_info: *const crate::vk1_3::BlitImageInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdCopyBufferToImage2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_copy_buffer_to_image_info: *const crate::vk1_3::CopyBufferToImageInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdCopyImageToBuffer2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_copy_image_to_buffer_info: *const crate::vk1_3::CopyImageToBufferInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdResolveImage2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_resolve_image_info: *const crate::vk1_3::ResolveImageInfo2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdSetEvent2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    event: crate::vk1_0::Event,
    p_dependency_info: *const crate::vk1_3::DependencyInfo,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdResetEvent2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    event: crate::vk1_0::Event,
    stage_mask: crate::vk1_3::PipelineStageFlags2,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdWaitEvents2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    event_count: u32,
    p_events: *const crate::vk1_0::Event,
    p_dependency_infos: *const crate::vk1_3::DependencyInfo,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdPipelineBarrier2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_dependency_info: *const crate::vk1_3::DependencyInfo,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkQueueSubmit2 = unsafe extern "system" fn(
    queue: crate::vk1_0::Queue,
    submit_count: u32,
    p_submits: *const crate::vk1_3::SubmitInfo2,
    fence: crate::vk1_0::Fence,
) -> crate::vk1_0::Result;
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdWriteTimestamp2 = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    stage: crate::vk1_3::PipelineStageFlags2,
    query_pool: crate::vk1_0::QueryPool,
    query: u32,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdBeginRendering = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
    p_rendering_info: *const crate::vk1_3::RenderingInfo,
) -> ();
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html) · Function
#[allow(non_camel_case_types)]
pub type PFN_vkCmdEndRendering = unsafe extern "system" fn(
    command_buffer: crate::vk1_0::CommandBuffer,
) -> ();
impl<'a> crate::ExtendableFrom<'a, DevicePrivateDataCreateInfo>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, DevicePrivateDataCreateInfoBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePrivateDataFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePrivateDataFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4Features>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4FeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceTextureCompressionASTCHDRFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderDemoteToHelperInvocationFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'_>,
> for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePipelineCreationCacheControlFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'_>,
> for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13Features>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13FeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'_>,
> for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceImageRobustnessFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceImageRobustnessFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderTerminateInvocationFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSynchronization2Features>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSynchronization2FeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceDynamicRenderingFeatures>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceDynamicRenderingFeaturesBuilder<'_>>
for crate::vk1_0::DeviceCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, WriteDescriptorSetInlineUniformBlock>
for crate::vk1_0::WriteDescriptorSetBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, WriteDescriptorSetInlineUniformBlockBuilder<'_>>
for crate::vk1_0::WriteDescriptorSetBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, DescriptorPoolInlineUniformBlockCreateInfo>
for crate::vk1_0::DescriptorPoolCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, DescriptorPoolInlineUniformBlockCreateInfoBuilder<'_>>
for crate::vk1_0::DescriptorPoolCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineShaderStageRequiredSubgroupSizeCreateInfo>
for crate::vk1_0::PipelineShaderStageCreateInfoBuilder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'_>>
for crate::vk1_0::PipelineShaderStageCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfo>
for crate::vk1_0::ComputePipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfoBuilder<'_>>
for crate::vk1_0::ComputePipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfo>
for crate::vk1_0::GraphicsPipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfoBuilder<'_>>
for crate::vk1_0::GraphicsPipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineRenderingCreateInfo>
for crate::vk1_0::GraphicsPipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineRenderingCreateInfoBuilder<'_>>
for crate::vk1_0::GraphicsPipelineCreateInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, CommandBufferInheritanceRenderingInfo>
for crate::vk1_0::CommandBufferInheritanceInfoBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, CommandBufferInheritanceRenderingInfoBuilder<'_>>
for crate::vk1_0::CommandBufferInheritanceInfoBuilder<'a> {}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html) · Structure
#[doc(alias = "VkDevicePrivateDataCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct DevicePrivateDataCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub private_data_slot_request_count: u32,
}
impl DevicePrivateDataCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO;
}
impl Default for DevicePrivateDataCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            private_data_slot_request_count: Default::default(),
        }
    }
}
impl std::fmt::Debug for DevicePrivateDataCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("DevicePrivateDataCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "private_data_slot_request_count",
                &self.private_data_slot_request_count,
            )
            .finish()
    }
}
impl DevicePrivateDataCreateInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> DevicePrivateDataCreateInfoBuilder<'a> {
        DevicePrivateDataCreateInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html) · Builder of [`DevicePrivateDataCreateInfo`]
#[repr(transparent)]
pub struct DevicePrivateDataCreateInfoBuilder<'a>(
    DevicePrivateDataCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> DevicePrivateDataCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> DevicePrivateDataCreateInfoBuilder<'a> {
        DevicePrivateDataCreateInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn private_data_slot_request_count(
        mut self,
        private_data_slot_request_count: u32,
    ) -> Self {
        self.0.private_data_slot_request_count = private_data_slot_request_count as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> DevicePrivateDataCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default for DevicePrivateDataCreateInfoBuilder<'a> {
    fn default() -> DevicePrivateDataCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for DevicePrivateDataCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for DevicePrivateDataCreateInfoBuilder<'a> {
    type Target = DevicePrivateDataCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for DevicePrivateDataCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html) · Structure
#[doc(alias = "VkPrivateDataSlotCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PrivateDataSlotCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub flags: crate::vk1_3::PrivateDataSlotCreateFlags,
}
impl PrivateDataSlotCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PRIVATE_DATA_SLOT_CREATE_INFO;
}
impl Default for PrivateDataSlotCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            flags: Default::default(),
        }
    }
}
impl std::fmt::Debug for PrivateDataSlotCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PrivateDataSlotCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
impl PrivateDataSlotCreateInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> PrivateDataSlotCreateInfoBuilder<'a> {
        PrivateDataSlotCreateInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html) · Builder of [`PrivateDataSlotCreateInfo`]
#[repr(transparent)]
pub struct PrivateDataSlotCreateInfoBuilder<'a>(
    PrivateDataSlotCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PrivateDataSlotCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> PrivateDataSlotCreateInfoBuilder<'a> {
        PrivateDataSlotCreateInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn flags(mut self, flags: crate::vk1_3::PrivateDataSlotCreateFlags) -> Self {
        self.0.flags = flags as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PrivateDataSlotCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default for PrivateDataSlotCreateInfoBuilder<'a> {
    fn default() -> PrivateDataSlotCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PrivateDataSlotCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PrivateDataSlotCreateInfoBuilder<'a> {
    type Target = PrivateDataSlotCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PrivateDataSlotCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html) · Structure
#[doc(alias = "VkPhysicalDevicePrivateDataFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDevicePrivateDataFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub private_data: crate::vk1_0::Bool32,
}
impl PhysicalDevicePrivateDataFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
}
impl Default for PhysicalDevicePrivateDataFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            private_data: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDevicePrivateDataFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDevicePrivateDataFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("private_data", &(self.private_data != 0))
            .finish()
    }
}
impl PhysicalDevicePrivateDataFeatures {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
        PhysicalDevicePrivateDataFeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html) · Builder of [`PhysicalDevicePrivateDataFeatures`]
#[repr(transparent)]
pub struct PhysicalDevicePrivateDataFeaturesBuilder<'a>(
    PhysicalDevicePrivateDataFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
        PhysicalDevicePrivateDataFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.0.private_data = private_data as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDevicePrivateDataFeatures {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    fn default() -> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    type Target = PhysicalDevicePrivateDataFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePrivateDataFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePrivateDataFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4Features>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4FeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceTextureCompressionASTCHDRFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderDemoteToHelperInvocationFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'_>,
> for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDevicePipelineCreationCacheControlFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'_>,
> for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13Features>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13FeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<
    'a,
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'_>,
> for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceImageRobustnessFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceImageRobustnessFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderTerminateInvocationFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSynchronization2Features>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSynchronization2FeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceDynamicRenderingFeatures>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceDynamicRenderingFeaturesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceFeatures2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockProperties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceInlineUniformBlockPropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4Properties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceMaintenance4PropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceTexelBufferAlignmentProperties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlProperties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13Properties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceVulkan13PropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductProperties>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<
    'a,
> crate::ExtendableFrom<'a, PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'_>>
for crate::vk1_1::PhysicalDeviceProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, FormatProperties3>
for crate::vk1_1::FormatProperties2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, FormatProperties3Builder<'_>>
for crate::vk1_1::FormatProperties2Builder<'a> {}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html) · Structure
#[doc(alias = "VkDeviceBufferMemoryRequirements")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct DeviceBufferMemoryRequirements {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub p_create_info: *const crate::vk1_0::BufferCreateInfo,
}
impl DeviceBufferMemoryRequirements {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS;
}
impl Default for DeviceBufferMemoryRequirements {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            p_create_info: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for DeviceBufferMemoryRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("DeviceBufferMemoryRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .finish()
    }
}
impl DeviceBufferMemoryRequirements {
    #[inline]
    pub fn into_builder<'a>(self) -> DeviceBufferMemoryRequirementsBuilder<'a> {
        DeviceBufferMemoryRequirementsBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html) · Builder of [`DeviceBufferMemoryRequirements`]
#[repr(transparent)]
pub struct DeviceBufferMemoryRequirementsBuilder<'a>(
    DeviceBufferMemoryRequirements,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> DeviceBufferMemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn new() -> DeviceBufferMemoryRequirementsBuilder<'a> {
        DeviceBufferMemoryRequirementsBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn create_info(
        mut self,
        create_info: &'a crate::vk1_0::BufferCreateInfo,
    ) -> Self {
        self.0.p_create_info = create_info as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> DeviceBufferMemoryRequirements {
        self.0
    }
}
impl<'a> std::default::Default for DeviceBufferMemoryRequirementsBuilder<'a> {
    fn default() -> DeviceBufferMemoryRequirementsBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for DeviceBufferMemoryRequirementsBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for DeviceBufferMemoryRequirementsBuilder<'a> {
    type Target = DeviceBufferMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for DeviceBufferMemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html) · Structure
#[doc(alias = "VkDeviceImageMemoryRequirements")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct DeviceImageMemoryRequirements {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub p_create_info: *const crate::vk1_0::ImageCreateInfo,
    pub plane_aspect: crate::vk1_0::ImageAspectFlagBits,
}
impl DeviceImageMemoryRequirements {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS;
}
impl Default for DeviceImageMemoryRequirements {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            p_create_info: std::ptr::null(),
            plane_aspect: Default::default(),
        }
    }
}
impl std::fmt::Debug for DeviceImageMemoryRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("DeviceImageMemoryRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
impl DeviceImageMemoryRequirements {
    #[inline]
    pub fn into_builder<'a>(self) -> DeviceImageMemoryRequirementsBuilder<'a> {
        DeviceImageMemoryRequirementsBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html) · Builder of [`DeviceImageMemoryRequirements`]
#[repr(transparent)]
pub struct DeviceImageMemoryRequirementsBuilder<'a>(
    DeviceImageMemoryRequirements,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> DeviceImageMemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn new() -> DeviceImageMemoryRequirementsBuilder<'a> {
        DeviceImageMemoryRequirementsBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn create_info(
        mut self,
        create_info: &'a crate::vk1_0::ImageCreateInfo,
    ) -> Self {
        self.0.p_create_info = create_info as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn plane_aspect(
        mut self,
        plane_aspect: crate::vk1_0::ImageAspectFlagBits,
    ) -> Self {
        self.0.plane_aspect = plane_aspect as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> DeviceImageMemoryRequirements {
        self.0
    }
}
impl<'a> std::default::Default for DeviceImageMemoryRequirementsBuilder<'a> {
    fn default() -> DeviceImageMemoryRequirementsBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for DeviceImageMemoryRequirementsBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for DeviceImageMemoryRequirementsBuilder<'a> {
    type Target = DeviceImageMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for DeviceImageMemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceInlineUniformBlockFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub inline_uniform_block: crate::vk1_0::Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: crate::vk1_0::Bool32,
}
impl PhysicalDeviceInlineUniformBlockFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
}
impl Default for PhysicalDeviceInlineUniformBlockFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceInlineUniformBlockFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceInlineUniformBlockFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("inline_uniform_block", &(self.inline_uniform_block != 0))
            .field(
                "descriptor_binding_inline_uniform_block_update_after_bind",
                &(self.descriptor_binding_inline_uniform_block_update_after_bind != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceInlineUniformBlockFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockFeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html) · Builder of [`PhysicalDeviceInlineUniformBlockFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a>(
    PhysicalDeviceInlineUniformBlockFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.0.inline_uniform_block = inline_uniform_block as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self
            .0
            .descriptor_binding_inline_uniform_block_update_after_bind = descriptor_binding_inline_uniform_block_update_after_bind
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceInlineUniformBlockFeatures {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    type Target = PhysicalDeviceInlineUniformBlockFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html) · Structure
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockProperties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceInlineUniformBlockProperties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
}
impl PhysicalDeviceInlineUniformBlockProperties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
}
impl Default for PhysicalDeviceInlineUniformBlockProperties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            max_inline_uniform_block_size: Default::default(),
            max_per_stage_descriptor_inline_uniform_blocks: Default::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: Default::default(),
            max_descriptor_set_inline_uniform_blocks: Default::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceInlineUniformBlockProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceInlineUniformBlockProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_inline_uniform_block_size", &self.max_inline_uniform_block_size)
            .field(
                "max_per_stage_descriptor_inline_uniform_blocks",
                &self.max_per_stage_descriptor_inline_uniform_blocks,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks",
                &self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_inline_uniform_blocks",
                &self.max_descriptor_set_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_update_after_bind_inline_uniform_blocks",
                &self.max_descriptor_set_update_after_bind_inline_uniform_blocks,
            )
            .finish()
    }
}
impl PhysicalDeviceInlineUniformBlockProperties {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockPropertiesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html) · Builder of [`PhysicalDeviceInlineUniformBlockProperties`]
#[repr(transparent)]
pub struct PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a>(
    PhysicalDeviceInlineUniformBlockProperties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockPropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn max_inline_uniform_block_size(
        mut self,
        max_inline_uniform_block_size: u32,
    ) -> Self {
        self.0.max_inline_uniform_block_size = max_inline_uniform_block_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_per_stage_descriptor_inline_uniform_blocks = max_per_stage_descriptor_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_descriptor_set_inline_uniform_blocks = max_descriptor_set_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_descriptor_set_update_after_bind_inline_uniform_blocks = max_descriptor_set_update_after_bind_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceInlineUniformBlockProperties {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    type Target = PhysicalDeviceInlineUniformBlockProperties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html) · Structure
#[doc(alias = "VkWriteDescriptorSetInlineUniformBlock")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct WriteDescriptorSetInlineUniformBlock {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub data_size: u32,
    pub p_data: *const std::ffi::c_void,
}
impl WriteDescriptorSetInlineUniformBlock {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
}
impl Default for WriteDescriptorSetInlineUniformBlock {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            data_size: Default::default(),
            p_data: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for WriteDescriptorSetInlineUniformBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("WriteDescriptorSetInlineUniformBlock")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
impl WriteDescriptorSetInlineUniformBlock {
    #[inline]
    pub fn into_builder<'a>(self) -> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
        WriteDescriptorSetInlineUniformBlockBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html) · Builder of [`WriteDescriptorSetInlineUniformBlock`]
#[repr(transparent)]
pub struct WriteDescriptorSetInlineUniformBlockBuilder<'a>(
    WriteDescriptorSetInlineUniformBlock,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    #[inline]
    pub fn new() -> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
        WriteDescriptorSetInlineUniformBlockBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn data_size(mut self, data_size: u32) -> Self {
        self.0.data_size = data_size;
        self
    }
    #[inline]
    #[must_use]
    pub fn data(mut self, data: *const std::ffi::c_void) -> Self {
        self.0.p_data = data;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> WriteDescriptorSetInlineUniformBlock {
        self.0
    }
}
impl<'a> std::default::Default for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    fn default() -> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    type Target = WriteDescriptorSetInlineUniformBlock;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html) · Structure
#[doc(alias = "VkDescriptorPoolInlineUniformBlockCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct DescriptorPoolInlineUniformBlockCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub max_inline_uniform_block_bindings: u32,
}
impl DescriptorPoolInlineUniformBlockCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
}
impl Default for DescriptorPoolInlineUniformBlockCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            max_inline_uniform_block_bindings: Default::default(),
        }
    }
}
impl std::fmt::Debug for DescriptorPoolInlineUniformBlockCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("DescriptorPoolInlineUniformBlockCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_inline_uniform_block_bindings",
                &self.max_inline_uniform_block_bindings,
            )
            .finish()
    }
}
impl DescriptorPoolInlineUniformBlockCreateInfo {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
        DescriptorPoolInlineUniformBlockCreateInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html) · Builder of [`DescriptorPoolInlineUniformBlockCreateInfo`]
#[repr(transparent)]
pub struct DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a>(
    DescriptorPoolInlineUniformBlockCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
        DescriptorPoolInlineUniformBlockCreateInfoBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn max_inline_uniform_block_bindings(
        mut self,
        max_inline_uniform_block_bindings: u32,
    ) -> Self {
        self
            .0
            .max_inline_uniform_block_bindings = max_inline_uniform_block_bindings as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> DescriptorPoolInlineUniformBlockCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default
for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    fn default() -> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    type Target = DescriptorPoolInlineUniformBlockCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html) · Structure
#[doc(alias = "VkPhysicalDeviceMaintenance4Features")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceMaintenance4Features {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub maintenance4: crate::vk1_0::Bool32,
}
impl PhysicalDeviceMaintenance4Features {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
}
impl Default for PhysicalDeviceMaintenance4Features {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            maintenance4: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceMaintenance4Features {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceMaintenance4Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("maintenance4", &(self.maintenance4 != 0))
            .finish()
    }
}
impl PhysicalDeviceMaintenance4Features {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
        PhysicalDeviceMaintenance4FeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html) · Builder of [`PhysicalDeviceMaintenance4Features`]
#[repr(transparent)]
pub struct PhysicalDeviceMaintenance4FeaturesBuilder<'a>(
    PhysicalDeviceMaintenance4Features,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
        PhysicalDeviceMaintenance4FeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.0.maintenance4 = maintenance4 as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceMaintenance4Features {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    type Target = PhysicalDeviceMaintenance4Features;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html) · Structure
#[doc(alias = "VkPhysicalDeviceMaintenance4Properties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceMaintenance4Properties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub max_buffer_size: crate::vk1_0::DeviceSize,
}
impl PhysicalDeviceMaintenance4Properties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
}
impl Default for PhysicalDeviceMaintenance4Properties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            max_buffer_size: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceMaintenance4Properties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceMaintenance4Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_buffer_size", &self.max_buffer_size)
            .finish()
    }
}
impl PhysicalDeviceMaintenance4Properties {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
        PhysicalDeviceMaintenance4PropertiesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html) · Builder of [`PhysicalDeviceMaintenance4Properties`]
#[repr(transparent)]
pub struct PhysicalDeviceMaintenance4PropertiesBuilder<'a>(
    PhysicalDeviceMaintenance4Properties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
        PhysicalDeviceMaintenance4PropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn max_buffer_size(mut self, max_buffer_size: crate::vk1_0::DeviceSize) -> Self {
        self.0.max_buffer_size = max_buffer_size as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceMaintenance4Properties {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    type Target = PhysicalDeviceMaintenance4Properties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'a> crate::ExtendableFrom<'a, MemoryBarrier2>
for crate::vk1_2::SubpassDependency2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, MemoryBarrier2Builder<'_>>
for crate::vk1_2::SubpassDependency2Builder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfo>
for crate::extensions::nv_ray_tracing::RayTracingPipelineCreateInfoNVBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfoBuilder<'_>>
for crate::extensions::nv_ray_tracing::RayTracingPipelineCreateInfoNVBuilder<'a> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfo>
for crate::extensions::khr_ray_tracing_pipeline::RayTracingPipelineCreateInfoKHRBuilder<
    'a,
> {}
impl<'a> crate::ExtendableFrom<'a, PipelineCreationFeedbackCreateInfoBuilder<'_>>
for crate::extensions::khr_ray_tracing_pipeline::RayTracingPipelineCreateInfoKHRBuilder<
    'a,
> {}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceTextureCompressionASTCHDRFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub texture_compression_astc_hdr: crate::vk1_0::Bool32,
}
impl PhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
}
impl Default for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            texture_compression_astc_hdr: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceTextureCompressionASTCHDRFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "texture_compression_astc_hdr",
                &(self.texture_compression_astc_hdr != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceTextureCompressionASTCHDRFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
        PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html) · Builder of [`PhysicalDeviceTextureCompressionASTCHDRFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a>(
    PhysicalDeviceTextureCompressionASTCHDRFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
        PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn texture_compression_astc_hdr(
        mut self,
        texture_compression_astc_hdr: bool,
    ) -> Self {
        self.0.texture_compression_astc_hdr = texture_compression_astc_hdr as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceTextureCompressionASTCHDRFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    type Target = PhysicalDeviceTextureCompressionASTCHDRFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html) · Structure
#[doc(alias = "VkPipelineCreationFeedback")]
#[derive(Copy, Clone, Hash, PartialEq, Eq, )]
#[repr(C)]
pub struct PipelineCreationFeedback {
    pub flags: crate::vk1_3::PipelineCreationFeedbackFlags,
    pub duration: u64,
}
impl Default for PipelineCreationFeedback {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            duration: Default::default(),
        }
    }
}
impl std::fmt::Debug for PipelineCreationFeedback {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PipelineCreationFeedback")
            .field("flags", &self.flags)
            .field("duration", &self.duration)
            .finish()
    }
}
impl PipelineCreationFeedback {
    #[inline]
    pub fn into_builder<'a>(self) -> PipelineCreationFeedbackBuilder<'a> {
        PipelineCreationFeedbackBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html) · Builder of [`PipelineCreationFeedback`]
#[repr(transparent)]
pub struct PipelineCreationFeedbackBuilder<'a>(
    PipelineCreationFeedback,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PipelineCreationFeedbackBuilder<'a> {
    #[inline]
    pub fn new() -> PipelineCreationFeedbackBuilder<'a> {
        PipelineCreationFeedbackBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn flags(mut self, flags: crate::vk1_3::PipelineCreationFeedbackFlags) -> Self {
        self.0.flags = flags as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn duration(mut self, duration: u64) -> Self {
        self.0.duration = duration as _;
        self
    }
    #[inline]
    pub fn build(self) -> PipelineCreationFeedback {
        self.0
    }
}
impl<'a> std::default::Default for PipelineCreationFeedbackBuilder<'a> {
    fn default() -> PipelineCreationFeedbackBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PipelineCreationFeedbackBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PipelineCreationFeedbackBuilder<'a> {
    type Target = PipelineCreationFeedback;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PipelineCreationFeedbackBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html) · Structure
#[doc(alias = "VkPipelineCreationFeedbackCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PipelineCreationFeedbackCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub p_pipeline_creation_feedback: *mut crate::vk1_3::PipelineCreationFeedback,
    pub pipeline_stage_creation_feedback_count: u32,
    pub p_pipeline_stage_creation_feedbacks: *mut crate::vk1_3::PipelineCreationFeedback,
}
impl PipelineCreationFeedbackCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
}
impl Default for PipelineCreationFeedbackCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            p_pipeline_creation_feedback: std::ptr::null_mut(),
            pipeline_stage_creation_feedback_count: Default::default(),
            p_pipeline_stage_creation_feedbacks: std::ptr::null_mut(),
        }
    }
}
impl std::fmt::Debug for PipelineCreationFeedbackCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PipelineCreationFeedbackCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_pipeline_creation_feedback", &self.p_pipeline_creation_feedback)
            .field(
                "pipeline_stage_creation_feedback_count",
                &self.pipeline_stage_creation_feedback_count,
            )
            .field(
                "p_pipeline_stage_creation_feedbacks",
                &self.p_pipeline_stage_creation_feedbacks,
            )
            .finish()
    }
}
impl PipelineCreationFeedbackCreateInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> PipelineCreationFeedbackCreateInfoBuilder<'a> {
        PipelineCreationFeedbackCreateInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html) · Builder of [`PipelineCreationFeedbackCreateInfo`]
#[repr(transparent)]
pub struct PipelineCreationFeedbackCreateInfoBuilder<'a>(
    PipelineCreationFeedbackCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PipelineCreationFeedbackCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> PipelineCreationFeedbackCreateInfoBuilder<'a> {
        PipelineCreationFeedbackCreateInfoBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn pipeline_creation_feedback(
        mut self,
        pipeline_creation_feedback: &'a mut crate::vk1_3::PipelineCreationFeedback,
    ) -> Self {
        self.0.p_pipeline_creation_feedback = pipeline_creation_feedback as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn pipeline_stage_creation_feedbacks(
        mut self,
        pipeline_stage_creation_feedbacks: &'a mut [crate::vk1_3::PipelineCreationFeedbackBuilder],
    ) -> Self {
        self
            .0
            .p_pipeline_stage_creation_feedbacks = pipeline_stage_creation_feedbacks
            .as_ptr() as _;
        self
            .0
            .pipeline_stage_creation_feedback_count = pipeline_stage_creation_feedbacks
            .len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PipelineCreationFeedbackCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    fn default() -> PipelineCreationFeedbackCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    type Target = PipelineCreationFeedbackCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub shader_demote_to_helper_invocation: crate::vk1_0::Bool32,
}
impl PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
}
impl Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            shader_demote_to_helper_invocation: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceShaderDemoteToHelperInvocationFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_demote_to_helper_invocation",
                &(self.shader_demote_to_helper_invocation != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html) · Builder of [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a>(
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self
            .0
            .shader_demote_to_helper_invocation = shader_demote_to_helper_invocation
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug
for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref
for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html) · Structure
#[doc(alias = "VkPhysicalDeviceTexelBufferAlignmentProperties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceTexelBufferAlignmentProperties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub storage_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: crate::vk1_0::Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: crate::vk1_0::Bool32,
}
impl PhysicalDeviceTexelBufferAlignmentProperties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
}
impl Default for PhysicalDeviceTexelBufferAlignmentProperties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: Default::default(),
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceTexelBufferAlignmentProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceTexelBufferAlignmentProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "storage_texel_buffer_offset_alignment_bytes",
                &self.storage_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "storage_texel_buffer_offset_single_texel_alignment",
                &(self.storage_texel_buffer_offset_single_texel_alignment != 0),
            )
            .field(
                "uniform_texel_buffer_offset_alignment_bytes",
                &self.uniform_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "uniform_texel_buffer_offset_single_texel_alignment",
                &(self.uniform_texel_buffer_offset_single_texel_alignment != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceTexelBufferAlignmentProperties {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
        PhysicalDeviceTexelBufferAlignmentPropertiesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html) · Builder of [`PhysicalDeviceTexelBufferAlignmentProperties`]
#[repr(transparent)]
pub struct PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a>(
    PhysicalDeviceTexelBufferAlignmentProperties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
        PhysicalDeviceTexelBufferAlignmentPropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    ) -> Self {
        self
            .0
            .storage_texel_buffer_offset_alignment_bytes = storage_texel_buffer_offset_alignment_bytes
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self
            .0
            .storage_texel_buffer_offset_single_texel_alignment = storage_texel_buffer_offset_single_texel_alignment
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    ) -> Self {
        self
            .0
            .uniform_texel_buffer_offset_alignment_bytes = uniform_texel_buffer_offset_alignment_bytes
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self
            .0
            .uniform_texel_buffer_offset_single_texel_alignment = uniform_texel_buffer_offset_single_texel_alignment
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceTexelBufferAlignmentProperties {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    type Target = PhysicalDeviceTexelBufferAlignmentProperties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceSubgroupSizeControlFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub subgroup_size_control: crate::vk1_0::Bool32,
    pub compute_full_subgroups: crate::vk1_0::Bool32,
}
impl PhysicalDeviceSubgroupSizeControlFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
}
impl Default for PhysicalDeviceSubgroupSizeControlFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceSubgroupSizeControlFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceSubgroupSizeControlFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subgroup_size_control", &(self.subgroup_size_control != 0))
            .field("compute_full_subgroups", &(self.compute_full_subgroups != 0))
            .finish()
    }
}
impl PhysicalDeviceSubgroupSizeControlFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlFeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html) · Builder of [`PhysicalDeviceSubgroupSizeControlFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a>(
    PhysicalDeviceSubgroupSizeControlFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.0.subgroup_size_control = subgroup_size_control as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.0.compute_full_subgroups = compute_full_subgroups as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceSubgroupSizeControlFeatures {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    type Target = PhysicalDeviceSubgroupSizeControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html) · Structure
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlProperties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceSubgroupSizeControlProperties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: crate::vk1_0::ShaderStageFlags,
}
impl PhysicalDeviceSubgroupSizeControlProperties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
}
impl Default for PhysicalDeviceSubgroupSizeControlProperties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            min_subgroup_size: Default::default(),
            max_subgroup_size: Default::default(),
            max_compute_workgroup_subgroups: Default::default(),
            required_subgroup_size_stages: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceSubgroupSizeControlProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceSubgroupSizeControlProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_subgroup_size", &self.min_subgroup_size)
            .field("max_subgroup_size", &self.max_subgroup_size)
            .field(
                "max_compute_workgroup_subgroups",
                &self.max_compute_workgroup_subgroups,
            )
            .field("required_subgroup_size_stages", &self.required_subgroup_size_stages)
            .finish()
    }
}
impl PhysicalDeviceSubgroupSizeControlProperties {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlPropertiesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html) · Builder of [`PhysicalDeviceSubgroupSizeControlProperties`]
#[repr(transparent)]
pub struct PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a>(
    PhysicalDeviceSubgroupSizeControlProperties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlPropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.0.min_subgroup_size = min_subgroup_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.0.max_subgroup_size = max_subgroup_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_compute_workgroup_subgroups(
        mut self,
        max_compute_workgroup_subgroups: u32,
    ) -> Self {
        self.0.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: crate::vk1_0::ShaderStageFlags,
    ) -> Self {
        self.0.required_subgroup_size_stages = required_subgroup_size_stages as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceSubgroupSizeControlProperties {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    type Target = PhysicalDeviceSubgroupSizeControlProperties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html) · Structure
#[doc(alias = "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub required_subgroup_size: u32,
}
impl PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
}
impl Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            required_subgroup_size: Default::default(),
        }
    }
}
impl std::fmt::Debug for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PipelineShaderStageRequiredSubgroupSizeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("required_subgroup_size", &self.required_subgroup_size)
            .finish()
    }
}
impl PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
        PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html) · Builder of [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
#[repr(transparent)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a>(
    PipelineShaderStageRequiredSubgroupSizeCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
        PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn required_subgroup_size(mut self, required_subgroup_size: u32) -> Self {
        self.0.required_subgroup_size = required_subgroup_size as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PipelineShaderStageRequiredSubgroupSizeCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default
for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    fn default() -> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug
for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref
for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    type Target = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html) · Structure
#[doc(alias = "VkPhysicalDevicePipelineCreationCacheControlFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub pipeline_creation_cache_control: crate::vk1_0::Bool32,
}
impl PhysicalDevicePipelineCreationCacheControlFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
}
impl Default for PhysicalDevicePipelineCreationCacheControlFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            pipeline_creation_cache_control: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDevicePipelineCreationCacheControlFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDevicePipelineCreationCacheControlFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "pipeline_creation_cache_control",
                &(self.pipeline_creation_cache_control != 0),
            )
            .finish()
    }
}
impl PhysicalDevicePipelineCreationCacheControlFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
        PhysicalDevicePipelineCreationCacheControlFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html) · Builder of [`PhysicalDevicePipelineCreationCacheControlFeatures`]
#[repr(transparent)]
pub struct PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a>(
    PhysicalDevicePipelineCreationCacheControlFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
        PhysicalDevicePipelineCreationCacheControlFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.0.pipeline_creation_cache_control = pipeline_creation_cache_control as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDevicePipelineCreationCacheControlFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    fn default() -> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug
for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref
for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    type Target = PhysicalDevicePipelineCreationCacheControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html) · Structure
#[doc(alias = "VkPhysicalDeviceVulkan13Features")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceVulkan13Features {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub robust_image_access: crate::vk1_0::Bool32,
    pub inline_uniform_block: crate::vk1_0::Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: crate::vk1_0::Bool32,
    pub pipeline_creation_cache_control: crate::vk1_0::Bool32,
    pub private_data: crate::vk1_0::Bool32,
    pub shader_demote_to_helper_invocation: crate::vk1_0::Bool32,
    pub shader_terminate_invocation: crate::vk1_0::Bool32,
    pub subgroup_size_control: crate::vk1_0::Bool32,
    pub compute_full_subgroups: crate::vk1_0::Bool32,
    pub synchronization2: crate::vk1_0::Bool32,
    pub texture_compression_astc_hdr: crate::vk1_0::Bool32,
    pub shader_zero_initialize_workgroup_memory: crate::vk1_0::Bool32,
    pub dynamic_rendering: crate::vk1_0::Bool32,
    pub shader_integer_dot_product: crate::vk1_0::Bool32,
    pub maintenance4: crate::vk1_0::Bool32,
}
impl PhysicalDeviceVulkan13Features {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
}
impl Default for PhysicalDeviceVulkan13Features {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            robust_image_access: Default::default(),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
            pipeline_creation_cache_control: Default::default(),
            private_data: Default::default(),
            shader_demote_to_helper_invocation: Default::default(),
            shader_terminate_invocation: Default::default(),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
            synchronization2: Default::default(),
            texture_compression_astc_hdr: Default::default(),
            shader_zero_initialize_workgroup_memory: Default::default(),
            dynamic_rendering: Default::default(),
            shader_integer_dot_product: Default::default(),
            maintenance4: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceVulkan13Features {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceVulkan13Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_image_access", &(self.robust_image_access != 0))
            .field("inline_uniform_block", &(self.inline_uniform_block != 0))
            .field(
                "descriptor_binding_inline_uniform_block_update_after_bind",
                &(self.descriptor_binding_inline_uniform_block_update_after_bind != 0),
            )
            .field(
                "pipeline_creation_cache_control",
                &(self.pipeline_creation_cache_control != 0),
            )
            .field("private_data", &(self.private_data != 0))
            .field(
                "shader_demote_to_helper_invocation",
                &(self.shader_demote_to_helper_invocation != 0),
            )
            .field(
                "shader_terminate_invocation",
                &(self.shader_terminate_invocation != 0),
            )
            .field("subgroup_size_control", &(self.subgroup_size_control != 0))
            .field("compute_full_subgroups", &(self.compute_full_subgroups != 0))
            .field("synchronization2", &(self.synchronization2 != 0))
            .field(
                "texture_compression_astc_hdr",
                &(self.texture_compression_astc_hdr != 0),
            )
            .field(
                "shader_zero_initialize_workgroup_memory",
                &(self.shader_zero_initialize_workgroup_memory != 0),
            )
            .field("dynamic_rendering", &(self.dynamic_rendering != 0))
            .field("shader_integer_dot_product", &(self.shader_integer_dot_product != 0))
            .field("maintenance4", &(self.maintenance4 != 0))
            .finish()
    }
}
impl PhysicalDeviceVulkan13Features {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
        PhysicalDeviceVulkan13FeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html) · Builder of [`PhysicalDeviceVulkan13Features`]
#[repr(transparent)]
pub struct PhysicalDeviceVulkan13FeaturesBuilder<'a>(
    PhysicalDeviceVulkan13Features,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
        PhysicalDeviceVulkan13FeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.0.robust_image_access = robust_image_access as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.0.inline_uniform_block = inline_uniform_block as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self
            .0
            .descriptor_binding_inline_uniform_block_update_after_bind = descriptor_binding_inline_uniform_block_update_after_bind
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.0.pipeline_creation_cache_control = pipeline_creation_cache_control as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.0.private_data = private_data as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self
            .0
            .shader_demote_to_helper_invocation = shader_demote_to_helper_invocation
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn shader_terminate_invocation(
        mut self,
        shader_terminate_invocation: bool,
    ) -> Self {
        self.0.shader_terminate_invocation = shader_terminate_invocation as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.0.subgroup_size_control = subgroup_size_control as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.0.compute_full_subgroups = compute_full_subgroups as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.0.synchronization2 = synchronization2 as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn texture_compression_astc_hdr(
        mut self,
        texture_compression_astc_hdr: bool,
    ) -> Self {
        self.0.texture_compression_astc_hdr = texture_compression_astc_hdr as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self
            .0
            .shader_zero_initialize_workgroup_memory = shader_zero_initialize_workgroup_memory
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.0.dynamic_rendering = dynamic_rendering as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn shader_integer_dot_product(
        mut self,
        shader_integer_dot_product: bool,
    ) -> Self {
        self.0.shader_integer_dot_product = shader_integer_dot_product as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.0.maintenance4 = maintenance4 as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceVulkan13Features {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    type Target = PhysicalDeviceVulkan13Features;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html) · Structure
#[doc(alias = "VkPhysicalDeviceVulkan13Properties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceVulkan13Properties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: crate::vk1_0::ShaderStageFlags,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub max_inline_uniform_total_size: u32,
    pub integer_dot_product8_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product8_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub storage_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: crate::vk1_0::Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: crate::vk1_0::Bool32,
    pub max_buffer_size: crate::vk1_0::DeviceSize,
}
impl PhysicalDeviceVulkan13Properties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
}
impl Default for PhysicalDeviceVulkan13Properties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            min_subgroup_size: Default::default(),
            max_subgroup_size: Default::default(),
            max_compute_workgroup_subgroups: Default::default(),
            required_subgroup_size_stages: Default::default(),
            max_inline_uniform_block_size: Default::default(),
            max_per_stage_descriptor_inline_uniform_blocks: Default::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: Default::default(),
            max_descriptor_set_inline_uniform_blocks: Default::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: Default::default(),
            max_inline_uniform_total_size: Default::default(),
            integer_dot_product8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product8_bit_signed_accelerated: Default::default(),
            integer_dot_product8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product16_bit_signed_accelerated: Default::default(),
            integer_dot_product16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product32_bit_signed_accelerated: Default::default(),
            integer_dot_product32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product64_bit_signed_accelerated: Default::default(),
            integer_dot_product64_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Default::default(),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: Default::default(),
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Default::default(),
            max_buffer_size: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceVulkan13Properties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceVulkan13Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_subgroup_size", &self.min_subgroup_size)
            .field("max_subgroup_size", &self.max_subgroup_size)
            .field(
                "max_compute_workgroup_subgroups",
                &self.max_compute_workgroup_subgroups,
            )
            .field("required_subgroup_size_stages", &self.required_subgroup_size_stages)
            .field("max_inline_uniform_block_size", &self.max_inline_uniform_block_size)
            .field(
                "max_per_stage_descriptor_inline_uniform_blocks",
                &self.max_per_stage_descriptor_inline_uniform_blocks,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks",
                &self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_inline_uniform_blocks",
                &self.max_descriptor_set_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_update_after_bind_inline_uniform_blocks",
                &self.max_descriptor_set_update_after_bind_inline_uniform_blocks,
            )
            .field("max_inline_uniform_total_size", &self.max_inline_uniform_total_size)
            .field(
                "integer_dot_product8_bit_unsigned_accelerated",
                &(self.integer_dot_product8_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product8_bit_signed_accelerated",
                &(self.integer_dot_product8_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product8_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product8_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_unsigned_accelerated",
                &(self.integer_dot_product4x8_bit_packed_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_signed_accelerated",
                &(self.integer_dot_product4x8_bit_packed_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_mixed_signedness_accelerated",
                &(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product16_bit_unsigned_accelerated",
                &(self.integer_dot_product16_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product16_bit_signed_accelerated",
                &(self.integer_dot_product16_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product16_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product16_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_unsigned_accelerated",
                &(self.integer_dot_product32_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_signed_accelerated",
                &(self.integer_dot_product32_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product32_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_unsigned_accelerated",
                &(self.integer_dot_product64_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_signed_accelerated",
                &(self.integer_dot_product64_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product64_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "storage_texel_buffer_offset_alignment_bytes",
                &self.storage_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "storage_texel_buffer_offset_single_texel_alignment",
                &(self.storage_texel_buffer_offset_single_texel_alignment != 0),
            )
            .field(
                "uniform_texel_buffer_offset_alignment_bytes",
                &self.uniform_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "uniform_texel_buffer_offset_single_texel_alignment",
                &(self.uniform_texel_buffer_offset_single_texel_alignment != 0),
            )
            .field("max_buffer_size", &self.max_buffer_size)
            .finish()
    }
}
impl PhysicalDeviceVulkan13Properties {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
        PhysicalDeviceVulkan13PropertiesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html) · Builder of [`PhysicalDeviceVulkan13Properties`]
#[repr(transparent)]
pub struct PhysicalDeviceVulkan13PropertiesBuilder<'a>(
    PhysicalDeviceVulkan13Properties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
        PhysicalDeviceVulkan13PropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.0.min_subgroup_size = min_subgroup_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.0.max_subgroup_size = max_subgroup_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_compute_workgroup_subgroups(
        mut self,
        max_compute_workgroup_subgroups: u32,
    ) -> Self {
        self.0.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: crate::vk1_0::ShaderStageFlags,
    ) -> Self {
        self.0.required_subgroup_size_stages = required_subgroup_size_stages as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_inline_uniform_block_size(
        mut self,
        max_inline_uniform_block_size: u32,
    ) -> Self {
        self.0.max_inline_uniform_block_size = max_inline_uniform_block_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_per_stage_descriptor_inline_uniform_blocks = max_per_stage_descriptor_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_descriptor_set_inline_uniform_blocks = max_descriptor_set_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self
            .0
            .max_descriptor_set_update_after_bind_inline_uniform_blocks = max_descriptor_set_update_after_bind_inline_uniform_blocks
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_inline_uniform_total_size(
        mut self,
        max_inline_uniform_total_size: u32,
    ) -> Self {
        self.0.max_inline_uniform_total_size = max_inline_uniform_total_size as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_unsigned_accelerated = integer_dot_product8_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_signed_accelerated = integer_dot_product8_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_mixed_signedness_accelerated = integer_dot_product8_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_unsigned_accelerated = integer_dot_product4x8_bit_packed_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_signed_accelerated = integer_dot_product4x8_bit_packed_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_unsigned_accelerated = integer_dot_product16_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_signed_accelerated = integer_dot_product16_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_mixed_signedness_accelerated = integer_dot_product16_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_unsigned_accelerated = integer_dot_product32_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_signed_accelerated = integer_dot_product32_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_mixed_signedness_accelerated = integer_dot_product32_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_unsigned_accelerated = integer_dot_product64_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_signed_accelerated = integer_dot_product64_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_mixed_signedness_accelerated = integer_dot_product64_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_signed_accelerated = integer_dot_product_accumulating_saturating8_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_signed_accelerated = integer_dot_product_accumulating_saturating16_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_signed_accelerated = integer_dot_product_accumulating_saturating32_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_signed_accelerated = integer_dot_product_accumulating_saturating64_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    ) -> Self {
        self
            .0
            .storage_texel_buffer_offset_alignment_bytes = storage_texel_buffer_offset_alignment_bytes
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self
            .0
            .storage_texel_buffer_offset_single_texel_alignment = storage_texel_buffer_offset_single_texel_alignment
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: crate::vk1_0::DeviceSize,
    ) -> Self {
        self
            .0
            .uniform_texel_buffer_offset_alignment_bytes = uniform_texel_buffer_offset_alignment_bytes
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self
            .0
            .uniform_texel_buffer_offset_single_texel_alignment = uniform_texel_buffer_offset_single_texel_alignment
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn max_buffer_size(mut self, max_buffer_size: crate::vk1_0::DeviceSize) -> Self {
        self.0.max_buffer_size = max_buffer_size as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceVulkan13Properties {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    type Target = PhysicalDeviceVulkan13Properties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html) · Structure
#[doc(alias = "VkPhysicalDeviceToolProperties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceToolProperties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub name: [std::os::raw::c_char; 256],
    pub version: [std::os::raw::c_char; 256],
    pub purposes: crate::vk1_3::ToolPurposeFlags,
    pub description: [std::os::raw::c_char; 256],
    pub layer: [std::os::raw::c_char; 256],
}
impl PhysicalDeviceToolProperties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES;
}
impl Default for PhysicalDeviceToolProperties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            name: unsafe { std::mem::zeroed() },
            version: unsafe { std::mem::zeroed() },
            purposes: Default::default(),
            description: unsafe { std::mem::zeroed() },
            layer: unsafe { std::mem::zeroed() },
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceToolProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceToolProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", unsafe { &std::ffi::CStr::from_ptr(self.name.as_ptr()) })
            .field(
                "version",
                unsafe { &std::ffi::CStr::from_ptr(self.version.as_ptr()) },
            )
            .field("purposes", &self.purposes)
            .field(
                "description",
                unsafe { &std::ffi::CStr::from_ptr(self.description.as_ptr()) },
            )
            .field("layer", unsafe { &std::ffi::CStr::from_ptr(self.layer.as_ptr()) })
            .finish()
    }
}
impl PhysicalDeviceToolProperties {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceToolPropertiesBuilder<'a> {
        PhysicalDeviceToolPropertiesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html) · Builder of [`PhysicalDeviceToolProperties`]
#[repr(transparent)]
pub struct PhysicalDeviceToolPropertiesBuilder<'a>(
    PhysicalDeviceToolProperties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceToolPropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceToolPropertiesBuilder<'a> {
        PhysicalDeviceToolPropertiesBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn name(mut self, name: [std::os::raw::c_char; 256]) -> Self {
        self.0.name = name as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn version(mut self, version: [std::os::raw::c_char; 256]) -> Self {
        self.0.version = version as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn purposes(mut self, purposes: crate::vk1_3::ToolPurposeFlags) -> Self {
        self.0.purposes = purposes as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn description(mut self, description: [std::os::raw::c_char; 256]) -> Self {
        self.0.description = description as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn layer(mut self, layer: [std::os::raw::c_char; 256]) -> Self {
        self.0.layer = layer as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceToolProperties {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceToolPropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceToolPropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceToolPropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceToolPropertiesBuilder<'a> {
    type Target = PhysicalDeviceToolProperties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceToolPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub shader_zero_initialize_workgroup_memory: crate::vk1_0::Bool32,
}
impl PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
}
impl Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_zero_initialize_workgroup_memory",
                &(self.shader_zero_initialize_workgroup_memory != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
        PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html) · Builder of [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a>(
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
        PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self
            .0
            .shader_zero_initialize_workgroup_memory = shader_zero_initialize_workgroup_memory
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug
for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref
for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    type Target = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceImageRobustnessFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceImageRobustnessFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub robust_image_access: crate::vk1_0::Bool32,
}
impl PhysicalDeviceImageRobustnessFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
}
impl Default for PhysicalDeviceImageRobustnessFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            robust_image_access: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceImageRobustnessFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceImageRobustnessFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_image_access", &(self.robust_image_access != 0))
            .finish()
    }
}
impl PhysicalDeviceImageRobustnessFeatures {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
        PhysicalDeviceImageRobustnessFeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html) · Builder of [`PhysicalDeviceImageRobustnessFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceImageRobustnessFeaturesBuilder<'a>(
    PhysicalDeviceImageRobustnessFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
        PhysicalDeviceImageRobustnessFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.0.robust_image_access = robust_image_access as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceImageRobustnessFeatures {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    type Target = PhysicalDeviceImageRobustnessFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html) · Structure
#[doc(alias = "VkBufferCopy2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct BufferCopy2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_offset: crate::vk1_0::DeviceSize,
    pub dst_offset: crate::vk1_0::DeviceSize,
    pub size: crate::vk1_0::DeviceSize,
}
impl BufferCopy2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::BUFFER_COPY_2;
}
impl Default for BufferCopy2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl std::fmt::Debug for BufferCopy2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("BufferCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_offset", &self.src_offset)
            .field("dst_offset", &self.dst_offset)
            .field("size", &self.size)
            .finish()
    }
}
impl BufferCopy2 {
    #[inline]
    pub fn into_builder<'a>(self) -> BufferCopy2Builder<'a> {
        BufferCopy2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html) · Builder of [`BufferCopy2`]
#[repr(transparent)]
pub struct BufferCopy2Builder<'a>(BufferCopy2, std::marker::PhantomData<&'a ()>);
impl<'a> BufferCopy2Builder<'a> {
    #[inline]
    pub fn new() -> BufferCopy2Builder<'a> {
        BufferCopy2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_offset(mut self, src_offset: crate::vk1_0::DeviceSize) -> Self {
        self.0.src_offset = src_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_offset(mut self, dst_offset: crate::vk1_0::DeviceSize) -> Self {
        self.0.dst_offset = dst_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn size(mut self, size: crate::vk1_0::DeviceSize) -> Self {
        self.0.size = size as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> BufferCopy2 {
        self.0
    }
}
impl<'a> std::default::Default for BufferCopy2Builder<'a> {
    fn default() -> BufferCopy2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for BufferCopy2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for BufferCopy2Builder<'a> {
    type Target = BufferCopy2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for BufferCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html) · Structure
#[doc(alias = "VkImageCopy2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct ImageCopy2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub src_offset: crate::vk1_0::Offset3D,
    pub dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub dst_offset: crate::vk1_0::Offset3D,
    pub extent: crate::vk1_0::Extent3D,
}
impl ImageCopy2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::IMAGE_COPY_2;
}
impl Default for ImageCopy2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl std::fmt::Debug for ImageCopy2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("ImageCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
impl ImageCopy2 {
    #[inline]
    pub fn into_builder<'a>(self) -> ImageCopy2Builder<'a> {
        ImageCopy2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html) · Builder of [`ImageCopy2`]
#[repr(transparent)]
pub struct ImageCopy2Builder<'a>(ImageCopy2, std::marker::PhantomData<&'a ()>);
impl<'a> ImageCopy2Builder<'a> {
    #[inline]
    pub fn new() -> ImageCopy2Builder<'a> {
        ImageCopy2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_subresource(
        mut self,
        src_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.src_subresource = src_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_offset(mut self, src_offset: crate::vk1_0::Offset3D) -> Self {
        self.0.src_offset = src_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_subresource(
        mut self,
        dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.dst_subresource = dst_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_offset(mut self, dst_offset: crate::vk1_0::Offset3D) -> Self {
        self.0.dst_offset = dst_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn extent(mut self, extent: crate::vk1_0::Extent3D) -> Self {
        self.0.extent = extent as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> ImageCopy2 {
        self.0
    }
}
impl<'a> std::default::Default for ImageCopy2Builder<'a> {
    fn default() -> ImageCopy2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for ImageCopy2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for ImageCopy2Builder<'a> {
    type Target = ImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for ImageCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html) · Structure
#[doc(alias = "VkImageBlit2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct ImageBlit2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub src_offsets: [crate::vk1_0::Offset3D; 2],
    pub dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub dst_offsets: [crate::vk1_0::Offset3D; 2],
}
impl ImageBlit2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::IMAGE_BLIT_2;
}
impl Default for ImageBlit2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offsets: unsafe { std::mem::zeroed() },
            dst_subresource: Default::default(),
            dst_offsets: unsafe { std::mem::zeroed() },
        }
    }
}
impl std::fmt::Debug for ImageBlit2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("ImageBlit2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offsets", &self.src_offsets)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offsets", &self.dst_offsets)
            .finish()
    }
}
impl ImageBlit2 {
    #[inline]
    pub fn into_builder<'a>(self) -> ImageBlit2Builder<'a> {
        ImageBlit2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html) · Builder of [`ImageBlit2`]
#[repr(transparent)]
pub struct ImageBlit2Builder<'a>(ImageBlit2, std::marker::PhantomData<&'a ()>);
impl<'a> ImageBlit2Builder<'a> {
    #[inline]
    pub fn new() -> ImageBlit2Builder<'a> {
        ImageBlit2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_subresource(
        mut self,
        src_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.src_subresource = src_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_offsets(mut self, src_offsets: [crate::vk1_0::Offset3D; 2]) -> Self {
        self.0.src_offsets = src_offsets as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_subresource(
        mut self,
        dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.dst_subresource = dst_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_offsets(mut self, dst_offsets: [crate::vk1_0::Offset3D; 2]) -> Self {
        self.0.dst_offsets = dst_offsets as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> ImageBlit2 {
        self.0
    }
}
impl<'a> std::default::Default for ImageBlit2Builder<'a> {
    fn default() -> ImageBlit2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for ImageBlit2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for ImageBlit2Builder<'a> {
    type Target = ImageBlit2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for ImageBlit2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html) · Structure
#[doc(alias = "VkBufferImageCopy2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct BufferImageCopy2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub buffer_offset: crate::vk1_0::DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub image_offset: crate::vk1_0::Offset3D,
    pub image_extent: crate::vk1_0::Extent3D,
}
impl BufferImageCopy2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::BUFFER_IMAGE_COPY_2;
}
impl Default for BufferImageCopy2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            buffer_offset: Default::default(),
            buffer_row_length: Default::default(),
            buffer_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl std::fmt::Debug for BufferImageCopy2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("BufferImageCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_offset", &self.buffer_offset)
            .field("buffer_row_length", &self.buffer_row_length)
            .field("buffer_image_height", &self.buffer_image_height)
            .field("image_subresource", &self.image_subresource)
            .field("image_offset", &self.image_offset)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
impl BufferImageCopy2 {
    #[inline]
    pub fn into_builder<'a>(self) -> BufferImageCopy2Builder<'a> {
        BufferImageCopy2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html) · Builder of [`BufferImageCopy2`]
#[repr(transparent)]
pub struct BufferImageCopy2Builder<'a>(
    BufferImageCopy2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> BufferImageCopy2Builder<'a> {
    #[inline]
    pub fn new() -> BufferImageCopy2Builder<'a> {
        BufferImageCopy2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn buffer_offset(mut self, buffer_offset: crate::vk1_0::DeviceSize) -> Self {
        self.0.buffer_offset = buffer_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.0.buffer_row_length = buffer_row_length as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.0.buffer_image_height = buffer_image_height as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image_subresource(
        mut self,
        image_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.image_subresource = image_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image_offset(mut self, image_offset: crate::vk1_0::Offset3D) -> Self {
        self.0.image_offset = image_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image_extent(mut self, image_extent: crate::vk1_0::Extent3D) -> Self {
        self.0.image_extent = image_extent as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> BufferImageCopy2 {
        self.0
    }
}
impl<'a> std::default::Default for BufferImageCopy2Builder<'a> {
    fn default() -> BufferImageCopy2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for BufferImageCopy2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for BufferImageCopy2Builder<'a> {
    type Target = BufferImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for BufferImageCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html) · Structure
#[doc(alias = "VkImageResolve2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct ImageResolve2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub src_offset: crate::vk1_0::Offset3D,
    pub dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    pub dst_offset: crate::vk1_0::Offset3D,
    pub extent: crate::vk1_0::Extent3D,
}
impl ImageResolve2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::IMAGE_RESOLVE_2;
}
impl Default for ImageResolve2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl std::fmt::Debug for ImageResolve2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("ImageResolve2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
impl ImageResolve2 {
    #[inline]
    pub fn into_builder<'a>(self) -> ImageResolve2Builder<'a> {
        ImageResolve2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html) · Builder of [`ImageResolve2`]
#[repr(transparent)]
pub struct ImageResolve2Builder<'a>(ImageResolve2, std::marker::PhantomData<&'a ()>);
impl<'a> ImageResolve2Builder<'a> {
    #[inline]
    pub fn new() -> ImageResolve2Builder<'a> {
        ImageResolve2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_subresource(
        mut self,
        src_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.src_subresource = src_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_offset(mut self, src_offset: crate::vk1_0::Offset3D) -> Self {
        self.0.src_offset = src_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_subresource(
        mut self,
        dst_subresource: crate::vk1_0::ImageSubresourceLayers,
    ) -> Self {
        self.0.dst_subresource = dst_subresource as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_offset(mut self, dst_offset: crate::vk1_0::Offset3D) -> Self {
        self.0.dst_offset = dst_offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn extent(mut self, extent: crate::vk1_0::Extent3D) -> Self {
        self.0.extent = extent as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> ImageResolve2 {
        self.0
    }
}
impl<'a> std::default::Default for ImageResolve2Builder<'a> {
    fn default() -> ImageResolve2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for ImageResolve2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for ImageResolve2Builder<'a> {
    type Target = ImageResolve2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for ImageResolve2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html) · Structure
#[doc(alias = "VkCopyBufferInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CopyBufferInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_buffer: crate::vk1_0::Buffer,
    pub dst_buffer: crate::vk1_0::Buffer,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::BufferCopy2,
}
impl CopyBufferInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COPY_BUFFER_INFO_2;
}
impl Default for CopyBufferInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_buffer: Default::default(),
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for CopyBufferInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CopyBufferInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
impl CopyBufferInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> CopyBufferInfo2Builder<'a> {
        CopyBufferInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html) · Builder of [`CopyBufferInfo2`]
#[repr(transparent)]
pub struct CopyBufferInfo2Builder<'a>(CopyBufferInfo2, std::marker::PhantomData<&'a ()>);
impl<'a> CopyBufferInfo2Builder<'a> {
    #[inline]
    pub fn new() -> CopyBufferInfo2Builder<'a> {
        CopyBufferInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_buffer(mut self, src_buffer: crate::vk1_0::Buffer) -> Self {
        self.0.src_buffer = src_buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_buffer(mut self, dst_buffer: crate::vk1_0::Buffer) -> Self {
        self.0.dst_buffer = dst_buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(mut self, regions: &'a [crate::vk1_3::BufferCopy2Builder]) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CopyBufferInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for CopyBufferInfo2Builder<'a> {
    fn default() -> CopyBufferInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CopyBufferInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CopyBufferInfo2Builder<'a> {
    type Target = CopyBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CopyBufferInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html) · Structure
#[doc(alias = "VkCopyImageInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CopyImageInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_image: crate::vk1_0::Image,
    pub src_image_layout: crate::vk1_0::ImageLayout,
    pub dst_image: crate::vk1_0::Image,
    pub dst_image_layout: crate::vk1_0::ImageLayout,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::ImageCopy2,
}
impl CopyImageInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COPY_IMAGE_INFO_2;
}
impl Default for CopyImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for CopyImageInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CopyImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
impl CopyImageInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> CopyImageInfo2Builder<'a> {
        CopyImageInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html) · Builder of [`CopyImageInfo2`]
#[repr(transparent)]
pub struct CopyImageInfo2Builder<'a>(CopyImageInfo2, std::marker::PhantomData<&'a ()>);
impl<'a> CopyImageInfo2Builder<'a> {
    #[inline]
    pub fn new() -> CopyImageInfo2Builder<'a> {
        CopyImageInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_image(mut self, src_image: crate::vk1_0::Image) -> Self {
        self.0.src_image = src_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_image_layout(
        mut self,
        src_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.src_image_layout = src_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image(mut self, dst_image: crate::vk1_0::Image) -> Self {
        self.0.dst_image = dst_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image_layout(
        mut self,
        dst_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.dst_image_layout = dst_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(mut self, regions: &'a [crate::vk1_3::ImageCopy2Builder]) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CopyImageInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for CopyImageInfo2Builder<'a> {
    fn default() -> CopyImageInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CopyImageInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CopyImageInfo2Builder<'a> {
    type Target = CopyImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CopyImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html) · Structure
#[doc(alias = "VkBlitImageInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct BlitImageInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_image: crate::vk1_0::Image,
    pub src_image_layout: crate::vk1_0::ImageLayout,
    pub dst_image: crate::vk1_0::Image,
    pub dst_image_layout: crate::vk1_0::ImageLayout,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::ImageBlit2,
    pub filter: crate::vk1_0::Filter,
}
impl BlitImageInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::BLIT_IMAGE_INFO_2;
}
impl Default for BlitImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
            filter: Default::default(),
        }
    }
}
impl std::fmt::Debug for BlitImageInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("BlitImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .field("filter", &self.filter)
            .finish()
    }
}
impl BlitImageInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> BlitImageInfo2Builder<'a> {
        BlitImageInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html) · Builder of [`BlitImageInfo2`]
#[repr(transparent)]
pub struct BlitImageInfo2Builder<'a>(BlitImageInfo2, std::marker::PhantomData<&'a ()>);
impl<'a> BlitImageInfo2Builder<'a> {
    #[inline]
    pub fn new() -> BlitImageInfo2Builder<'a> {
        BlitImageInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_image(mut self, src_image: crate::vk1_0::Image) -> Self {
        self.0.src_image = src_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_image_layout(
        mut self,
        src_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.src_image_layout = src_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image(mut self, dst_image: crate::vk1_0::Image) -> Self {
        self.0.dst_image = dst_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image_layout(
        mut self,
        dst_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.dst_image_layout = dst_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(mut self, regions: &'a [crate::vk1_3::ImageBlit2Builder]) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn filter(mut self, filter: crate::vk1_0::Filter) -> Self {
        self.0.filter = filter as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> BlitImageInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for BlitImageInfo2Builder<'a> {
    fn default() -> BlitImageInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for BlitImageInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for BlitImageInfo2Builder<'a> {
    type Target = BlitImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for BlitImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html) · Structure
#[doc(alias = "VkCopyBufferToImageInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CopyBufferToImageInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_buffer: crate::vk1_0::Buffer,
    pub dst_image: crate::vk1_0::Image,
    pub dst_image_layout: crate::vk1_0::ImageLayout,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::BufferImageCopy2,
}
impl CopyBufferToImageInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COPY_BUFFER_TO_IMAGE_INFO_2;
}
impl Default for CopyBufferToImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_buffer: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for CopyBufferToImageInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CopyBufferToImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
impl CopyBufferToImageInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> CopyBufferToImageInfo2Builder<'a> {
        CopyBufferToImageInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html) · Builder of [`CopyBufferToImageInfo2`]
#[repr(transparent)]
pub struct CopyBufferToImageInfo2Builder<'a>(
    CopyBufferToImageInfo2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> CopyBufferToImageInfo2Builder<'a> {
    #[inline]
    pub fn new() -> CopyBufferToImageInfo2Builder<'a> {
        CopyBufferToImageInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_buffer(mut self, src_buffer: crate::vk1_0::Buffer) -> Self {
        self.0.src_buffer = src_buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image(mut self, dst_image: crate::vk1_0::Image) -> Self {
        self.0.dst_image = dst_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image_layout(
        mut self,
        dst_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.dst_image_layout = dst_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(
        mut self,
        regions: &'a [crate::vk1_3::BufferImageCopy2Builder],
    ) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CopyBufferToImageInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for CopyBufferToImageInfo2Builder<'a> {
    fn default() -> CopyBufferToImageInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CopyBufferToImageInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CopyBufferToImageInfo2Builder<'a> {
    type Target = CopyBufferToImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CopyBufferToImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html) · Structure
#[doc(alias = "VkCopyImageToBufferInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CopyImageToBufferInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_image: crate::vk1_0::Image,
    pub src_image_layout: crate::vk1_0::ImageLayout,
    pub dst_buffer: crate::vk1_0::Buffer,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::BufferImageCopy2,
}
impl CopyImageToBufferInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COPY_IMAGE_TO_BUFFER_INFO_2;
}
impl Default for CopyImageToBufferInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for CopyImageToBufferInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CopyImageToBufferInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
impl CopyImageToBufferInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> CopyImageToBufferInfo2Builder<'a> {
        CopyImageToBufferInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html) · Builder of [`CopyImageToBufferInfo2`]
#[repr(transparent)]
pub struct CopyImageToBufferInfo2Builder<'a>(
    CopyImageToBufferInfo2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> CopyImageToBufferInfo2Builder<'a> {
    #[inline]
    pub fn new() -> CopyImageToBufferInfo2Builder<'a> {
        CopyImageToBufferInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_image(mut self, src_image: crate::vk1_0::Image) -> Self {
        self.0.src_image = src_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_image_layout(
        mut self,
        src_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.src_image_layout = src_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_buffer(mut self, dst_buffer: crate::vk1_0::Buffer) -> Self {
        self.0.dst_buffer = dst_buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(
        mut self,
        regions: &'a [crate::vk1_3::BufferImageCopy2Builder],
    ) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CopyImageToBufferInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for CopyImageToBufferInfo2Builder<'a> {
    fn default() -> CopyImageToBufferInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CopyImageToBufferInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CopyImageToBufferInfo2Builder<'a> {
    type Target = CopyImageToBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CopyImageToBufferInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html) · Structure
#[doc(alias = "VkResolveImageInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct ResolveImageInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_image: crate::vk1_0::Image,
    pub src_image_layout: crate::vk1_0::ImageLayout,
    pub dst_image: crate::vk1_0::Image,
    pub dst_image_layout: crate::vk1_0::ImageLayout,
    pub region_count: u32,
    pub p_regions: *const crate::vk1_3::ImageResolve2,
}
impl ResolveImageInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::RESOLVE_IMAGE_INFO_2;
}
impl Default for ResolveImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for ResolveImageInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("ResolveImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
impl ResolveImageInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> ResolveImageInfo2Builder<'a> {
        ResolveImageInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html) · Builder of [`ResolveImageInfo2`]
#[repr(transparent)]
pub struct ResolveImageInfo2Builder<'a>(
    ResolveImageInfo2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> ResolveImageInfo2Builder<'a> {
    #[inline]
    pub fn new() -> ResolveImageInfo2Builder<'a> {
        ResolveImageInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_image(mut self, src_image: crate::vk1_0::Image) -> Self {
        self.0.src_image = src_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_image_layout(
        mut self,
        src_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.src_image_layout = src_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image(mut self, dst_image: crate::vk1_0::Image) -> Self {
        self.0.dst_image = dst_image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_image_layout(
        mut self,
        dst_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.dst_image_layout = dst_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn regions(mut self, regions: &'a [crate::vk1_3::ImageResolve2Builder]) -> Self {
        self.0.p_regions = regions.as_ptr() as _;
        self.0.region_count = regions.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> ResolveImageInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for ResolveImageInfo2Builder<'a> {
    fn default() -> ResolveImageInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for ResolveImageInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for ResolveImageInfo2Builder<'a> {
    type Target = ResolveImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for ResolveImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceShaderTerminateInvocationFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub shader_terminate_invocation: crate::vk1_0::Bool32,
}
impl PhysicalDeviceShaderTerminateInvocationFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
}
impl Default for PhysicalDeviceShaderTerminateInvocationFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            shader_terminate_invocation: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceShaderTerminateInvocationFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceShaderTerminateInvocationFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_terminate_invocation",
                &(self.shader_terminate_invocation != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceShaderTerminateInvocationFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderTerminateInvocationFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html) · Builder of [`PhysicalDeviceShaderTerminateInvocationFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a>(
    PhysicalDeviceShaderTerminateInvocationFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderTerminateInvocationFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn shader_terminate_invocation(
        mut self,
        shader_terminate_invocation: bool,
    ) -> Self {
        self.0.shader_terminate_invocation = shader_terminate_invocation as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceShaderTerminateInvocationFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderTerminateInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html) · Structure
#[doc(alias = "VkMemoryBarrier2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct MemoryBarrier2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub src_access_mask: crate::vk1_3::AccessFlags2,
    pub dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub dst_access_mask: crate::vk1_3::AccessFlags2,
}
impl MemoryBarrier2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::MEMORY_BARRIER_2;
}
impl Default for MemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
        }
    }
}
impl std::fmt::Debug for MemoryBarrier2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("MemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .finish()
    }
}
impl MemoryBarrier2 {
    #[inline]
    pub fn into_builder<'a>(self) -> MemoryBarrier2Builder<'a> {
        MemoryBarrier2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html) · Builder of [`MemoryBarrier2`]
#[repr(transparent)]
pub struct MemoryBarrier2Builder<'a>(MemoryBarrier2, std::marker::PhantomData<&'a ()>);
impl<'a> MemoryBarrier2Builder<'a> {
    #[inline]
    pub fn new() -> MemoryBarrier2Builder<'a> {
        MemoryBarrier2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_stage_mask(
        mut self,
        src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.src_stage_mask = src_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_access_mask(
        mut self,
        src_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.src_access_mask = src_access_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_stage_mask(
        mut self,
        dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.dst_stage_mask = dst_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_access_mask(
        mut self,
        dst_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.dst_access_mask = dst_access_mask as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> MemoryBarrier2 {
        self.0
    }
}
impl<'a> std::default::Default for MemoryBarrier2Builder<'a> {
    fn default() -> MemoryBarrier2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for MemoryBarrier2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for MemoryBarrier2Builder<'a> {
    type Target = MemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for MemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html) · Structure
#[doc(alias = "VkImageMemoryBarrier2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct ImageMemoryBarrier2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub src_access_mask: crate::vk1_3::AccessFlags2,
    pub dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub dst_access_mask: crate::vk1_3::AccessFlags2,
    pub old_layout: crate::vk1_0::ImageLayout,
    pub new_layout: crate::vk1_0::ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: crate::vk1_0::Image,
    pub subresource_range: crate::vk1_0::ImageSubresourceRange,
}
impl ImageMemoryBarrier2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::IMAGE_MEMORY_BARRIER_2;
}
impl Default for ImageMemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: Default::default(),
            new_layout: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            image: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl std::fmt::Debug for ImageMemoryBarrier2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("ImageMemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("old_layout", &self.old_layout)
            .field("new_layout", &self.new_layout)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("image", &self.image)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
impl ImageMemoryBarrier2 {
    #[inline]
    pub fn into_builder<'a>(self) -> ImageMemoryBarrier2Builder<'a> {
        ImageMemoryBarrier2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html) · Builder of [`ImageMemoryBarrier2`]
#[repr(transparent)]
pub struct ImageMemoryBarrier2Builder<'a>(
    ImageMemoryBarrier2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> ImageMemoryBarrier2Builder<'a> {
    #[inline]
    pub fn new() -> ImageMemoryBarrier2Builder<'a> {
        ImageMemoryBarrier2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_stage_mask(
        mut self,
        src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.src_stage_mask = src_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_access_mask(
        mut self,
        src_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.src_access_mask = src_access_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_stage_mask(
        mut self,
        dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.dst_stage_mask = dst_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_access_mask(
        mut self,
        dst_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.dst_access_mask = dst_access_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn old_layout(mut self, old_layout: crate::vk1_0::ImageLayout) -> Self {
        self.0.old_layout = old_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn new_layout(mut self, new_layout: crate::vk1_0::ImageLayout) -> Self {
        self.0.new_layout = new_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.0.src_queue_family_index = src_queue_family_index as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.0.dst_queue_family_index = dst_queue_family_index as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image(mut self, image: crate::vk1_0::Image) -> Self {
        self.0.image = image as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn subresource_range(
        mut self,
        subresource_range: crate::vk1_0::ImageSubresourceRange,
    ) -> Self {
        self.0.subresource_range = subresource_range as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> ImageMemoryBarrier2 {
        self.0
    }
}
impl<'a> std::default::Default for ImageMemoryBarrier2Builder<'a> {
    fn default() -> ImageMemoryBarrier2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for ImageMemoryBarrier2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for ImageMemoryBarrier2Builder<'a> {
    type Target = ImageMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for ImageMemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html) · Structure
#[doc(alias = "VkBufferMemoryBarrier2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct BufferMemoryBarrier2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub src_access_mask: crate::vk1_3::AccessFlags2,
    pub dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub dst_access_mask: crate::vk1_3::AccessFlags2,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: crate::vk1_0::Buffer,
    pub offset: crate::vk1_0::DeviceSize,
    pub size: crate::vk1_0::DeviceSize,
}
impl BufferMemoryBarrier2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::BUFFER_MEMORY_BARRIER_2;
}
impl Default for BufferMemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl std::fmt::Debug for BufferMemoryBarrier2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("BufferMemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
impl BufferMemoryBarrier2 {
    #[inline]
    pub fn into_builder<'a>(self) -> BufferMemoryBarrier2Builder<'a> {
        BufferMemoryBarrier2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html) · Builder of [`BufferMemoryBarrier2`]
#[repr(transparent)]
pub struct BufferMemoryBarrier2Builder<'a>(
    BufferMemoryBarrier2,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> BufferMemoryBarrier2Builder<'a> {
    #[inline]
    pub fn new() -> BufferMemoryBarrier2Builder<'a> {
        BufferMemoryBarrier2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn src_stage_mask(
        mut self,
        src_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.src_stage_mask = src_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_access_mask(
        mut self,
        src_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.src_access_mask = src_access_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_stage_mask(
        mut self,
        dst_stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> Self {
        self.0.dst_stage_mask = dst_stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_access_mask(
        mut self,
        dst_access_mask: crate::vk1_3::AccessFlags2,
    ) -> Self {
        self.0.dst_access_mask = dst_access_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.0.src_queue_family_index = src_queue_family_index as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.0.dst_queue_family_index = dst_queue_family_index as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn buffer(mut self, buffer: crate::vk1_0::Buffer) -> Self {
        self.0.buffer = buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn offset(mut self, offset: crate::vk1_0::DeviceSize) -> Self {
        self.0.offset = offset as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn size(mut self, size: crate::vk1_0::DeviceSize) -> Self {
        self.0.size = size as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> BufferMemoryBarrier2 {
        self.0
    }
}
impl<'a> std::default::Default for BufferMemoryBarrier2Builder<'a> {
    fn default() -> BufferMemoryBarrier2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for BufferMemoryBarrier2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for BufferMemoryBarrier2Builder<'a> {
    type Target = BufferMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for BufferMemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html) · Structure
#[doc(alias = "VkDependencyInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct DependencyInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub dependency_flags: crate::vk1_0::DependencyFlags,
    pub memory_barrier_count: u32,
    pub p_memory_barriers: *const crate::vk1_3::MemoryBarrier2,
    pub buffer_memory_barrier_count: u32,
    pub p_buffer_memory_barriers: *const crate::vk1_3::BufferMemoryBarrier2,
    pub image_memory_barrier_count: u32,
    pub p_image_memory_barriers: *const crate::vk1_3::ImageMemoryBarrier2,
}
impl DependencyInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::DEPENDENCY_INFO;
}
impl Default for DependencyInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            dependency_flags: Default::default(),
            memory_barrier_count: Default::default(),
            p_memory_barriers: std::ptr::null(),
            buffer_memory_barrier_count: Default::default(),
            p_buffer_memory_barriers: std::ptr::null(),
            image_memory_barrier_count: Default::default(),
            p_image_memory_barriers: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for DependencyInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("DependencyInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dependency_flags", &self.dependency_flags)
            .field("memory_barrier_count", &self.memory_barrier_count)
            .field("p_memory_barriers", &self.p_memory_barriers)
            .field("buffer_memory_barrier_count", &self.buffer_memory_barrier_count)
            .field("p_buffer_memory_barriers", &self.p_buffer_memory_barriers)
            .field("image_memory_barrier_count", &self.image_memory_barrier_count)
            .field("p_image_memory_barriers", &self.p_image_memory_barriers)
            .finish()
    }
}
impl DependencyInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> DependencyInfoBuilder<'a> {
        DependencyInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html) · Builder of [`DependencyInfo`]
#[repr(transparent)]
pub struct DependencyInfoBuilder<'a>(DependencyInfo, std::marker::PhantomData<&'a ()>);
impl<'a> DependencyInfoBuilder<'a> {
    #[inline]
    pub fn new() -> DependencyInfoBuilder<'a> {
        DependencyInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn dependency_flags(
        mut self,
        dependency_flags: crate::vk1_0::DependencyFlags,
    ) -> Self {
        self.0.dependency_flags = dependency_flags as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn memory_barriers(
        mut self,
        memory_barriers: &'a [crate::vk1_3::MemoryBarrier2Builder],
    ) -> Self {
        self.0.p_memory_barriers = memory_barriers.as_ptr() as _;
        self.0.memory_barrier_count = memory_barriers.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn buffer_memory_barriers(
        mut self,
        buffer_memory_barriers: &'a [crate::vk1_3::BufferMemoryBarrier2Builder],
    ) -> Self {
        self.0.p_buffer_memory_barriers = buffer_memory_barriers.as_ptr() as _;
        self.0.buffer_memory_barrier_count = buffer_memory_barriers.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image_memory_barriers(
        mut self,
        image_memory_barriers: &'a [crate::vk1_3::ImageMemoryBarrier2Builder],
    ) -> Self {
        self.0.p_image_memory_barriers = image_memory_barriers.as_ptr() as _;
        self.0.image_memory_barrier_count = image_memory_barriers.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> DependencyInfo {
        self.0
    }
}
impl<'a> std::default::Default for DependencyInfoBuilder<'a> {
    fn default() -> DependencyInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for DependencyInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for DependencyInfoBuilder<'a> {
    type Target = DependencyInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for DependencyInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html) · Structure
#[doc(alias = "VkSemaphoreSubmitInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct SemaphoreSubmitInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub semaphore: crate::vk1_0::Semaphore,
    pub value: u64,
    pub stage_mask: crate::vk1_3::PipelineStageFlags2,
    pub device_index: u32,
}
impl SemaphoreSubmitInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::SEMAPHORE_SUBMIT_INFO;
}
impl Default for SemaphoreSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            semaphore: Default::default(),
            value: Default::default(),
            stage_mask: Default::default(),
            device_index: Default::default(),
        }
    }
}
impl std::fmt::Debug for SemaphoreSubmitInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("SemaphoreSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("value", &self.value)
            .field("stage_mask", &self.stage_mask)
            .field("device_index", &self.device_index)
            .finish()
    }
}
impl SemaphoreSubmitInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> SemaphoreSubmitInfoBuilder<'a> {
        SemaphoreSubmitInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html) · Builder of [`SemaphoreSubmitInfo`]
#[repr(transparent)]
pub struct SemaphoreSubmitInfoBuilder<'a>(
    SemaphoreSubmitInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> SemaphoreSubmitInfoBuilder<'a> {
    #[inline]
    pub fn new() -> SemaphoreSubmitInfoBuilder<'a> {
        SemaphoreSubmitInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn semaphore(mut self, semaphore: crate::vk1_0::Semaphore) -> Self {
        self.0.semaphore = semaphore as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn value(mut self, value: u64) -> Self {
        self.0.value = value as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn stage_mask(mut self, stage_mask: crate::vk1_3::PipelineStageFlags2) -> Self {
        self.0.stage_mask = stage_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn device_index(mut self, device_index: u32) -> Self {
        self.0.device_index = device_index as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> SemaphoreSubmitInfo {
        self.0
    }
}
impl<'a> std::default::Default for SemaphoreSubmitInfoBuilder<'a> {
    fn default() -> SemaphoreSubmitInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for SemaphoreSubmitInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for SemaphoreSubmitInfoBuilder<'a> {
    type Target = SemaphoreSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for SemaphoreSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html) · Structure
#[doc(alias = "VkCommandBufferSubmitInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CommandBufferSubmitInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub command_buffer: crate::vk1_0::CommandBuffer,
    pub device_mask: u32,
}
impl CommandBufferSubmitInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COMMAND_BUFFER_SUBMIT_INFO;
}
impl Default for CommandBufferSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            command_buffer: Default::default(),
            device_mask: Default::default(),
        }
    }
}
impl std::fmt::Debug for CommandBufferSubmitInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CommandBufferSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("command_buffer", &self.command_buffer)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
impl CommandBufferSubmitInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> CommandBufferSubmitInfoBuilder<'a> {
        CommandBufferSubmitInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html) · Builder of [`CommandBufferSubmitInfo`]
#[repr(transparent)]
pub struct CommandBufferSubmitInfoBuilder<'a>(
    CommandBufferSubmitInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> CommandBufferSubmitInfoBuilder<'a> {
    #[inline]
    pub fn new() -> CommandBufferSubmitInfoBuilder<'a> {
        CommandBufferSubmitInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn command_buffer(
        mut self,
        command_buffer: crate::vk1_0::CommandBuffer,
    ) -> Self {
        self.0.command_buffer = command_buffer as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.0.device_mask = device_mask as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CommandBufferSubmitInfo {
        self.0
    }
}
impl<'a> std::default::Default for CommandBufferSubmitInfoBuilder<'a> {
    fn default() -> CommandBufferSubmitInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CommandBufferSubmitInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CommandBufferSubmitInfoBuilder<'a> {
    type Target = CommandBufferSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CommandBufferSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html) · Structure
#[doc(alias = "VkSubmitInfo2")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct SubmitInfo2 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub flags: crate::vk1_3::SubmitFlags,
    pub wait_semaphore_info_count: u32,
    pub p_wait_semaphore_infos: *const crate::vk1_3::SemaphoreSubmitInfo,
    pub command_buffer_info_count: u32,
    pub p_command_buffer_infos: *const crate::vk1_3::CommandBufferSubmitInfo,
    pub signal_semaphore_info_count: u32,
    pub p_signal_semaphore_infos: *const crate::vk1_3::SemaphoreSubmitInfo,
}
impl SubmitInfo2 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::SUBMIT_INFO_2;
}
impl Default for SubmitInfo2 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            flags: Default::default(),
            wait_semaphore_info_count: Default::default(),
            p_wait_semaphore_infos: std::ptr::null(),
            command_buffer_info_count: Default::default(),
            p_command_buffer_infos: std::ptr::null(),
            signal_semaphore_info_count: Default::default(),
            p_signal_semaphore_infos: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for SubmitInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("SubmitInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("wait_semaphore_info_count", &self.wait_semaphore_info_count)
            .field("p_wait_semaphore_infos", &self.p_wait_semaphore_infos)
            .field("command_buffer_info_count", &self.command_buffer_info_count)
            .field("p_command_buffer_infos", &self.p_command_buffer_infos)
            .field("signal_semaphore_info_count", &self.signal_semaphore_info_count)
            .field("p_signal_semaphore_infos", &self.p_signal_semaphore_infos)
            .finish()
    }
}
impl SubmitInfo2 {
    #[inline]
    pub fn into_builder<'a>(self) -> SubmitInfo2Builder<'a> {
        SubmitInfo2Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html) · Builder of [`SubmitInfo2`]
#[repr(transparent)]
pub struct SubmitInfo2Builder<'a>(SubmitInfo2, std::marker::PhantomData<&'a ()>);
impl<'a> SubmitInfo2Builder<'a> {
    #[inline]
    pub fn new() -> SubmitInfo2Builder<'a> {
        SubmitInfo2Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn flags(mut self, flags: crate::vk1_3::SubmitFlags) -> Self {
        self.0.flags = flags as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn wait_semaphore_infos(
        mut self,
        wait_semaphore_infos: &'a [crate::vk1_3::SemaphoreSubmitInfoBuilder],
    ) -> Self {
        self.0.p_wait_semaphore_infos = wait_semaphore_infos.as_ptr() as _;
        self.0.wait_semaphore_info_count = wait_semaphore_infos.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn command_buffer_infos(
        mut self,
        command_buffer_infos: &'a [crate::vk1_3::CommandBufferSubmitInfoBuilder],
    ) -> Self {
        self.0.p_command_buffer_infos = command_buffer_infos.as_ptr() as _;
        self.0.command_buffer_info_count = command_buffer_infos.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn signal_semaphore_infos(
        mut self,
        signal_semaphore_infos: &'a [crate::vk1_3::SemaphoreSubmitInfoBuilder],
    ) -> Self {
        self.0.p_signal_semaphore_infos = signal_semaphore_infos.as_ptr() as _;
        self.0.signal_semaphore_info_count = signal_semaphore_infos.len() as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> SubmitInfo2 {
        self.0
    }
}
impl<'a> std::default::Default for SubmitInfo2Builder<'a> {
    fn default() -> SubmitInfo2Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for SubmitInfo2Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for SubmitInfo2Builder<'a> {
    type Target = SubmitInfo2;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for SubmitInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html) · Structure
#[doc(alias = "VkPhysicalDeviceSynchronization2Features")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceSynchronization2Features {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub synchronization2: crate::vk1_0::Bool32,
}
impl PhysicalDeviceSynchronization2Features {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
}
impl Default for PhysicalDeviceSynchronization2Features {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            synchronization2: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceSynchronization2Features {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceSynchronization2Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("synchronization2", &(self.synchronization2 != 0))
            .finish()
    }
}
impl PhysicalDeviceSynchronization2Features {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
        PhysicalDeviceSynchronization2FeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html) · Builder of [`PhysicalDeviceSynchronization2Features`]
#[repr(transparent)]
pub struct PhysicalDeviceSynchronization2FeaturesBuilder<'a>(
    PhysicalDeviceSynchronization2Features,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
        PhysicalDeviceSynchronization2FeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.0.synchronization2 = synchronization2 as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceSynchronization2Features {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    type Target = PhysicalDeviceSynchronization2Features;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub shader_integer_dot_product: crate::vk1_0::Bool32,
}
impl PhysicalDeviceShaderIntegerDotProductFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
}
impl Default for PhysicalDeviceShaderIntegerDotProductFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            shader_integer_dot_product: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceShaderIntegerDotProductFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceShaderIntegerDotProductFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_integer_dot_product", &(self.shader_integer_dot_product != 0))
            .finish()
    }
}
impl PhysicalDeviceShaderIntegerDotProductFeatures {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductFeaturesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html) · Builder of [`PhysicalDeviceShaderIntegerDotProductFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a>(
    PhysicalDeviceShaderIntegerDotProductFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn shader_integer_dot_product(
        mut self,
        shader_integer_dot_product: bool,
    ) -> Self {
        self.0.shader_integer_dot_product = shader_integer_dot_product as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceShaderIntegerDotProductFeatures {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderIntegerDotProductFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html) · Structure
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductProperties")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceShaderIntegerDotProductProperties {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub integer_dot_product8_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product8_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: crate::vk1_0::Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: crate::vk1_0::Bool32,
}
impl PhysicalDeviceShaderIntegerDotProductProperties {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
}
impl Default for PhysicalDeviceShaderIntegerDotProductProperties {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            integer_dot_product8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product8_bit_signed_accelerated: Default::default(),
            integer_dot_product8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product16_bit_signed_accelerated: Default::default(),
            integer_dot_product16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product32_bit_signed_accelerated: Default::default(),
            integer_dot_product32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product64_bit_signed_accelerated: Default::default(),
            integer_dot_product64_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceShaderIntegerDotProductProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceShaderIntegerDotProductProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "integer_dot_product8_bit_unsigned_accelerated",
                &(self.integer_dot_product8_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product8_bit_signed_accelerated",
                &(self.integer_dot_product8_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product8_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product8_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_unsigned_accelerated",
                &(self.integer_dot_product4x8_bit_packed_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_signed_accelerated",
                &(self.integer_dot_product4x8_bit_packed_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product4x8_bit_packed_mixed_signedness_accelerated",
                &(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product16_bit_unsigned_accelerated",
                &(self.integer_dot_product16_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product16_bit_signed_accelerated",
                &(self.integer_dot_product16_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product16_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product16_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_unsigned_accelerated",
                &(self.integer_dot_product32_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_signed_accelerated",
                &(self.integer_dot_product32_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product32_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product32_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_unsigned_accelerated",
                &(self.integer_dot_product64_bit_unsigned_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_signed_accelerated",
                &(self.integer_dot_product64_bit_signed_accelerated != 0),
            )
            .field(
                "integer_dot_product64_bit_mixed_signedness_accelerated",
                &(self.integer_dot_product64_bit_mixed_signedness_accelerated != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_signed_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_signed_accelerated
                    != 0),
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated",
                &(self
                    .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    != 0),
            )
            .finish()
    }
}
impl PhysicalDeviceShaderIntegerDotProductProperties {
    #[inline]
    pub fn into_builder<'a>(
        self,
    ) -> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductPropertiesBuilder(
            self,
            std::marker::PhantomData,
        )
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html) · Builder of [`PhysicalDeviceShaderIntegerDotProductProperties`]
#[repr(transparent)]
pub struct PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a>(
    PhysicalDeviceShaderIntegerDotProductProperties,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductPropertiesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_unsigned_accelerated = integer_dot_product8_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_signed_accelerated = integer_dot_product8_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product8_bit_mixed_signedness_accelerated = integer_dot_product8_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_unsigned_accelerated = integer_dot_product4x8_bit_packed_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_signed_accelerated = integer_dot_product4x8_bit_packed_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_unsigned_accelerated = integer_dot_product16_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_signed_accelerated = integer_dot_product16_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product16_bit_mixed_signedness_accelerated = integer_dot_product16_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_unsigned_accelerated = integer_dot_product32_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_signed_accelerated = integer_dot_product32_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product32_bit_mixed_signedness_accelerated = integer_dot_product32_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_unsigned_accelerated = integer_dot_product64_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_signed_accelerated = integer_dot_product64_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product64_bit_mixed_signedness_accelerated = integer_dot_product64_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_signed_accelerated = integer_dot_product_accumulating_saturating8_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_signed_accelerated = integer_dot_product_accumulating_saturating16_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_signed_accelerated = integer_dot_product_accumulating_saturating32_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_signed_accelerated = integer_dot_product_accumulating_saturating64_bit_signed_accelerated
            as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self
            .0
            .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
            as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceShaderIntegerDotProductProperties {
        self.0
    }
}
impl<'a> std::default::Default
for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    fn default() -> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    type Target = PhysicalDeviceShaderIntegerDotProductProperties;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut
for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html) · Structure
#[doc(alias = "VkFormatProperties3")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct FormatProperties3 {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub linear_tiling_features: crate::vk1_3::FormatFeatureFlags2,
    pub optimal_tiling_features: crate::vk1_3::FormatFeatureFlags2,
    pub buffer_features: crate::vk1_3::FormatFeatureFlags2,
}
impl FormatProperties3 {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::FORMAT_PROPERTIES_3;
}
impl Default for FormatProperties3 {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
        }
    }
}
impl std::fmt::Debug for FormatProperties3 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("FormatProperties3")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("linear_tiling_features", &self.linear_tiling_features)
            .field("optimal_tiling_features", &self.optimal_tiling_features)
            .field("buffer_features", &self.buffer_features)
            .finish()
    }
}
impl FormatProperties3 {
    #[inline]
    pub fn into_builder<'a>(self) -> FormatProperties3Builder<'a> {
        FormatProperties3Builder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html) · Builder of [`FormatProperties3`]
#[repr(transparent)]
pub struct FormatProperties3Builder<'a>(
    FormatProperties3,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> FormatProperties3Builder<'a> {
    #[inline]
    pub fn new() -> FormatProperties3Builder<'a> {
        FormatProperties3Builder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn linear_tiling_features(
        mut self,
        linear_tiling_features: crate::vk1_3::FormatFeatureFlags2,
    ) -> Self {
        self.0.linear_tiling_features = linear_tiling_features as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn optimal_tiling_features(
        mut self,
        optimal_tiling_features: crate::vk1_3::FormatFeatureFlags2,
    ) -> Self {
        self.0.optimal_tiling_features = optimal_tiling_features as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn buffer_features(
        mut self,
        buffer_features: crate::vk1_3::FormatFeatureFlags2,
    ) -> Self {
        self.0.buffer_features = buffer_features as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> FormatProperties3 {
        self.0
    }
}
impl<'a> std::default::Default for FormatProperties3Builder<'a> {
    fn default() -> FormatProperties3Builder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for FormatProperties3Builder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for FormatProperties3Builder<'a> {
    type Target = FormatProperties3;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for FormatProperties3Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html) · Structure
#[doc(alias = "VkPipelineRenderingCreateInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PipelineRenderingCreateInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const crate::vk1_0::Format,
    pub depth_attachment_format: crate::vk1_0::Format,
    pub stencil_attachment_format: crate::vk1_0::Format,
}
impl PipelineRenderingCreateInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PIPELINE_RENDERING_CREATE_INFO;
}
impl Default for PipelineRenderingCreateInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: std::ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
        }
    }
}
impl std::fmt::Debug for PipelineRenderingCreateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PipelineRenderingCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .finish()
    }
}
impl PipelineRenderingCreateInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> PipelineRenderingCreateInfoBuilder<'a> {
        PipelineRenderingCreateInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html) · Builder of [`PipelineRenderingCreateInfo`]
#[repr(transparent)]
pub struct PipelineRenderingCreateInfoBuilder<'a>(
    PipelineRenderingCreateInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PipelineRenderingCreateInfoBuilder<'a> {
    #[inline]
    pub fn new() -> PipelineRenderingCreateInfoBuilder<'a> {
        PipelineRenderingCreateInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.0.view_mask = view_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn color_attachment_formats(
        mut self,
        color_attachment_formats: &'a [crate::vk1_0::Format],
    ) -> Self {
        self.0.p_color_attachment_formats = color_attachment_formats.as_ptr() as _;
        self.0.color_attachment_count = color_attachment_formats.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn depth_attachment_format(
        mut self,
        depth_attachment_format: crate::vk1_0::Format,
    ) -> Self {
        self.0.depth_attachment_format = depth_attachment_format as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn stencil_attachment_format(
        mut self,
        stencil_attachment_format: crate::vk1_0::Format,
    ) -> Self {
        self.0.stencil_attachment_format = stencil_attachment_format as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PipelineRenderingCreateInfo {
        self.0
    }
}
impl<'a> std::default::Default for PipelineRenderingCreateInfoBuilder<'a> {
    fn default() -> PipelineRenderingCreateInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PipelineRenderingCreateInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PipelineRenderingCreateInfoBuilder<'a> {
    type Target = PipelineRenderingCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PipelineRenderingCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html) · Structure
#[doc(alias = "VkRenderingInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct RenderingInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub flags: crate::vk1_3::RenderingFlags,
    pub render_area: crate::vk1_0::Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const crate::vk1_3::RenderingAttachmentInfo,
    pub p_depth_attachment: *const crate::vk1_3::RenderingAttachmentInfo,
    pub p_stencil_attachment: *const crate::vk1_3::RenderingAttachmentInfo,
}
impl RenderingInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::RENDERING_INFO;
}
impl Default for RenderingInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            flags: Default::default(),
            render_area: Default::default(),
            layer_count: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachments: std::ptr::null(),
            p_depth_attachment: std::ptr::null(),
            p_stencil_attachment: std::ptr::null(),
        }
    }
}
impl std::fmt::Debug for RenderingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("RenderingInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("render_area", &self.render_area)
            .field("layer_count", &self.layer_count)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_depth_attachment", &self.p_depth_attachment)
            .field("p_stencil_attachment", &self.p_stencil_attachment)
            .finish()
    }
}
impl RenderingInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> RenderingInfoBuilder<'a> {
        RenderingInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html) · Builder of [`RenderingInfo`]
#[repr(transparent)]
pub struct RenderingInfoBuilder<'a>(RenderingInfo, std::marker::PhantomData<&'a ()>);
impl<'a> RenderingInfoBuilder<'a> {
    #[inline]
    pub fn new() -> RenderingInfoBuilder<'a> {
        RenderingInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn flags(mut self, flags: crate::vk1_3::RenderingFlags) -> Self {
        self.0.flags = flags as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn render_area(mut self, render_area: crate::vk1_0::Rect2D) -> Self {
        self.0.render_area = render_area as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.0.layer_count = layer_count as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.0.view_mask = view_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn color_attachments(
        mut self,
        color_attachments: &'a [crate::vk1_3::RenderingAttachmentInfoBuilder],
    ) -> Self {
        self.0.p_color_attachments = color_attachments.as_ptr() as _;
        self.0.color_attachment_count = color_attachments.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn depth_attachment(
        mut self,
        depth_attachment: &'a crate::vk1_3::RenderingAttachmentInfo,
    ) -> Self {
        self.0.p_depth_attachment = depth_attachment as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn stencil_attachment(
        mut self,
        stencil_attachment: &'a crate::vk1_3::RenderingAttachmentInfo,
    ) -> Self {
        self.0.p_stencil_attachment = stencil_attachment as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> RenderingInfo {
        self.0
    }
}
impl<'a> std::default::Default for RenderingInfoBuilder<'a> {
    fn default() -> RenderingInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for RenderingInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for RenderingInfoBuilder<'a> {
    type Target = RenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for RenderingInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html) · Structure
#[doc(alias = "VkRenderingAttachmentInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct RenderingAttachmentInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub image_view: crate::vk1_0::ImageView,
    pub image_layout: crate::vk1_0::ImageLayout,
    pub resolve_mode: crate::vk1_2::ResolveModeFlagBits,
    pub resolve_image_view: crate::vk1_0::ImageView,
    pub resolve_image_layout: crate::vk1_0::ImageLayout,
    pub load_op: crate::vk1_0::AttachmentLoadOp,
    pub store_op: crate::vk1_0::AttachmentStoreOp,
    pub clear_value: crate::vk1_0::ClearValue,
}
impl RenderingAttachmentInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::RENDERING_ATTACHMENT_INFO;
}
impl Default for RenderingAttachmentInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            image_view: Default::default(),
            image_layout: Default::default(),
            resolve_mode: Default::default(),
            resolve_image_view: Default::default(),
            resolve_image_layout: Default::default(),
            load_op: Default::default(),
            store_op: Default::default(),
            clear_value: Default::default(),
        }
    }
}
impl std::fmt::Debug for RenderingAttachmentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("RenderingAttachmentInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field("resolve_mode", &self.resolve_mode)
            .field("resolve_image_view", &self.resolve_image_view)
            .field("resolve_image_layout", &self.resolve_image_layout)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("clear_value", &self.clear_value)
            .finish()
    }
}
impl RenderingAttachmentInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> RenderingAttachmentInfoBuilder<'a> {
        RenderingAttachmentInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html) · Builder of [`RenderingAttachmentInfo`]
#[repr(transparent)]
pub struct RenderingAttachmentInfoBuilder<'a>(
    RenderingAttachmentInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> RenderingAttachmentInfoBuilder<'a> {
    #[inline]
    pub fn new() -> RenderingAttachmentInfoBuilder<'a> {
        RenderingAttachmentInfoBuilder(Default::default(), std::marker::PhantomData)
    }
    #[inline]
    #[must_use]
    pub fn image_view(mut self, image_view: crate::vk1_0::ImageView) -> Self {
        self.0.image_view = image_view as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn image_layout(mut self, image_layout: crate::vk1_0::ImageLayout) -> Self {
        self.0.image_layout = image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn resolve_mode(
        mut self,
        resolve_mode: crate::vk1_2::ResolveModeFlagBits,
    ) -> Self {
        self.0.resolve_mode = resolve_mode as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn resolve_image_view(
        mut self,
        resolve_image_view: crate::vk1_0::ImageView,
    ) -> Self {
        self.0.resolve_image_view = resolve_image_view as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn resolve_image_layout(
        mut self,
        resolve_image_layout: crate::vk1_0::ImageLayout,
    ) -> Self {
        self.0.resolve_image_layout = resolve_image_layout as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn load_op(mut self, load_op: crate::vk1_0::AttachmentLoadOp) -> Self {
        self.0.load_op = load_op as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn store_op(mut self, store_op: crate::vk1_0::AttachmentStoreOp) -> Self {
        self.0.store_op = store_op as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn clear_value(mut self, clear_value: crate::vk1_0::ClearValue) -> Self {
        self.0.clear_value = clear_value as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> RenderingAttachmentInfo {
        self.0
    }
}
impl<'a> std::default::Default for RenderingAttachmentInfoBuilder<'a> {
    fn default() -> RenderingAttachmentInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for RenderingAttachmentInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for RenderingAttachmentInfoBuilder<'a> {
    type Target = RenderingAttachmentInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for RenderingAttachmentInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html) · Structure
#[doc(alias = "VkPhysicalDeviceDynamicRenderingFeatures")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct PhysicalDeviceDynamicRenderingFeatures {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *mut std::ffi::c_void,
    pub dynamic_rendering: crate::vk1_0::Bool32,
}
impl PhysicalDeviceDynamicRenderingFeatures {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
}
impl Default for PhysicalDeviceDynamicRenderingFeatures {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null_mut(),
            dynamic_rendering: Default::default(),
        }
    }
}
impl std::fmt::Debug for PhysicalDeviceDynamicRenderingFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("PhysicalDeviceDynamicRenderingFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dynamic_rendering", &(self.dynamic_rendering != 0))
            .finish()
    }
}
impl PhysicalDeviceDynamicRenderingFeatures {
    #[inline]
    pub fn into_builder<'a>(self) -> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
        PhysicalDeviceDynamicRenderingFeaturesBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html) · Builder of [`PhysicalDeviceDynamicRenderingFeatures`]
#[repr(transparent)]
pub struct PhysicalDeviceDynamicRenderingFeaturesBuilder<'a>(
    PhysicalDeviceDynamicRenderingFeatures,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    #[inline]
    pub fn new() -> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
        PhysicalDeviceDynamicRenderingFeaturesBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.0.dynamic_rendering = dynamic_rendering as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> PhysicalDeviceDynamicRenderingFeatures {
        self.0
    }
}
impl<'a> std::default::Default for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    fn default() -> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    type Target = PhysicalDeviceDynamicRenderingFeatures;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html) · Structure
#[doc(alias = "VkCommandBufferInheritanceRenderingInfo")]
#[derive(Copy, Clone, )]
#[repr(C)]
pub struct CommandBufferInheritanceRenderingInfo {
    pub s_type: crate::vk1_0::StructureType,
    pub p_next: *const std::ffi::c_void,
    pub flags: crate::vk1_3::RenderingFlags,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const crate::vk1_0::Format,
    pub depth_attachment_format: crate::vk1_0::Format,
    pub stencil_attachment_format: crate::vk1_0::Format,
    pub rasterization_samples: crate::vk1_0::SampleCountFlagBits,
}
impl CommandBufferInheritanceRenderingInfo {
    pub const STRUCTURE_TYPE: crate::vk1_0::StructureType = crate::vk1_0::StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
}
impl Default for CommandBufferInheritanceRenderingInfo {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: std::ptr::null(),
            flags: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: std::ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
            rasterization_samples: Default::default(),
        }
    }
}
impl std::fmt::Debug for CommandBufferInheritanceRenderingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f
            .debug_struct("CommandBufferInheritanceRenderingInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .field("rasterization_samples", &self.rasterization_samples)
            .finish()
    }
}
impl CommandBufferInheritanceRenderingInfo {
    #[inline]
    pub fn into_builder<'a>(self) -> CommandBufferInheritanceRenderingInfoBuilder<'a> {
        CommandBufferInheritanceRenderingInfoBuilder(self, std::marker::PhantomData)
    }
}
#[derive(Copy, Clone)]
///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html) · Builder of [`CommandBufferInheritanceRenderingInfo`]
#[repr(transparent)]
pub struct CommandBufferInheritanceRenderingInfoBuilder<'a>(
    CommandBufferInheritanceRenderingInfo,
    std::marker::PhantomData<&'a ()>,
);
impl<'a> CommandBufferInheritanceRenderingInfoBuilder<'a> {
    #[inline]
    pub fn new() -> CommandBufferInheritanceRenderingInfoBuilder<'a> {
        CommandBufferInheritanceRenderingInfoBuilder(
            Default::default(),
            std::marker::PhantomData,
        )
    }
    #[inline]
    #[must_use]
    pub fn flags(mut self, flags: crate::vk1_3::RenderingFlags) -> Self {
        self.0.flags = flags as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.0.view_mask = view_mask as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn color_attachment_formats(
        mut self,
        color_attachment_formats: &'a [crate::vk1_0::Format],
    ) -> Self {
        self.0.p_color_attachment_formats = color_attachment_formats.as_ptr() as _;
        self.0.color_attachment_count = color_attachment_formats.len() as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn depth_attachment_format(
        mut self,
        depth_attachment_format: crate::vk1_0::Format,
    ) -> Self {
        self.0.depth_attachment_format = depth_attachment_format as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn stencil_attachment_format(
        mut self,
        stencil_attachment_format: crate::vk1_0::Format,
    ) -> Self {
        self.0.stencil_attachment_format = stencil_attachment_format as _;
        self
    }
    #[inline]
    #[must_use]
    pub fn rasterization_samples(
        mut self,
        rasterization_samples: crate::vk1_0::SampleCountFlagBits,
    ) -> Self {
        self.0.rasterization_samples = rasterization_samples as _;
        self
    }
    #[inline]
    /// Discards all lifetime information.
    /// Use the `Deref` and `DerefMut` implementations if possible.
    pub fn build_dangling(self) -> CommandBufferInheritanceRenderingInfo {
        self.0
    }
}
impl<'a> std::default::Default for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    fn default() -> CommandBufferInheritanceRenderingInfoBuilder<'a> {
        Self::new()
    }
}
impl<'a> std::fmt::Debug for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.0, f)
    }
}
impl<'a> std::ops::Deref for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    type Target = CommandBufferInheritanceRenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a> std::ops::DerefMut for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
///Provided by [`crate::vk1_3`]
impl crate::DeviceLoader {
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html) · Function
    #[doc(alias = "vkGetDeviceBufferMemoryRequirements")]
    pub unsafe fn get_device_buffer_memory_requirements(
        &self,
        info: &crate::vk1_3::DeviceBufferMemoryRequirements,
        memory_requirements: Option<crate::vk1_1::MemoryRequirements2>,
    ) -> crate::vk1_1::MemoryRequirements2 {
        let _function = self
            .get_device_buffer_memory_requirements
            .expect(crate::NOT_LOADED_MESSAGE);
        let mut memory_requirements = match memory_requirements {
            Some(v) => v,
            None => Default::default(),
        };
        let _return = _function(self.handle, info as _, &mut memory_requirements);
        memory_requirements
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html) · Function
    #[doc(alias = "vkGetDeviceImageMemoryRequirements")]
    pub unsafe fn get_device_image_memory_requirements(
        &self,
        info: &crate::vk1_3::DeviceImageMemoryRequirements,
        memory_requirements: Option<crate::vk1_1::MemoryRequirements2>,
    ) -> crate::vk1_1::MemoryRequirements2 {
        let _function = self
            .get_device_image_memory_requirements
            .expect(crate::NOT_LOADED_MESSAGE);
        let mut memory_requirements = match memory_requirements {
            Some(v) => v,
            None => Default::default(),
        };
        let _return = _function(self.handle, info as _, &mut memory_requirements);
        memory_requirements
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html) · Function
    #[doc(alias = "vkGetDeviceImageSparseMemoryRequirements")]
    pub unsafe fn get_device_image_sparse_memory_requirements(
        &self,
        info: &crate::vk1_3::DeviceImageMemoryRequirements,
        sparse_memory_requirement_count: Option<u32>,
        sparse_memory_requirements_callback: impl FnMut(
            &mut crate::SmallVec<crate::vk1_1::SparseImageMemoryRequirements2>,
        ) -> (),
    ) -> crate::SmallVec<crate::vk1_1::SparseImageMemoryRequirements2> {
        let _function = self
            .get_device_image_sparse_memory_requirements
            .expect(crate::NOT_LOADED_MESSAGE);
        let mut sparse_memory_requirement_count = match sparse_memory_requirement_count {
            Some(v) => v,
            None => {
                let mut v = Default::default();
                _function(self.handle, info as _, &mut v, std::ptr::null_mut());
                v
            }
        };
        let mut sparse_memory_requirements = crate::SmallVec::from_elem(
            Default::default(),
            sparse_memory_requirement_count as _,
        );
        let mut _callback = sparse_memory_requirements_callback;
        _callback(&mut sparse_memory_requirements);
        let _return = _function(
            self.handle,
            info as _,
            &mut sparse_memory_requirement_count,
            sparse_memory_requirements.as_mut_ptr(),
        );
        sparse_memory_requirements
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html) · Function
    #[doc(alias = "vkCmdSetCullMode")]
    pub unsafe fn cmd_set_cull_mode(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        cull_mode: crate::vk1_0::CullModeFlags,
    ) -> () {
        let _function = self.cmd_set_cull_mode.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, cull_mode as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html) · Function
    #[doc(alias = "vkCmdSetFrontFace")]
    pub unsafe fn cmd_set_front_face(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        front_face: crate::vk1_0::FrontFace,
    ) -> () {
        let _function = self.cmd_set_front_face.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, front_face as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html) · Function
    #[doc(alias = "vkCmdSetPrimitiveTopology")]
    pub unsafe fn cmd_set_primitive_topology(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        primitive_topology: crate::vk1_0::PrimitiveTopology,
    ) -> () {
        let _function = self
            .cmd_set_primitive_topology
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, primitive_topology as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html) · Function
    #[doc(alias = "vkCmdSetViewportWithCount")]
    pub unsafe fn cmd_set_viewport_with_count(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        viewports: &[crate::vk1_0::ViewportBuilder],
    ) -> () {
        let _function = self
            .cmd_set_viewport_with_count
            .expect(crate::NOT_LOADED_MESSAGE);
        let viewport_count = viewports.len();
        let _return = _function(
            command_buffer as _,
            viewport_count as _,
            viewports.as_ptr() as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html) · Function
    #[doc(alias = "vkCmdSetScissorWithCount")]
    pub unsafe fn cmd_set_scissor_with_count(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        scissors: &[crate::vk1_0::Rect2DBuilder],
    ) -> () {
        let _function = self
            .cmd_set_scissor_with_count
            .expect(crate::NOT_LOADED_MESSAGE);
        let scissor_count = scissors.len();
        let _return = _function(
            command_buffer as _,
            scissor_count as _,
            scissors.as_ptr() as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html) · Function
    #[doc(alias = "vkCmdBindVertexBuffers2")]
    pub unsafe fn cmd_bind_vertex_buffers2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        first_binding: u32,
        buffers: &[crate::vk1_0::Buffer],
        offsets: &[crate::vk1_0::DeviceSize],
        sizes: &[crate::vk1_0::DeviceSize],
        strides: &[crate::vk1_0::DeviceSize],
    ) -> () {
        let _function = self.cmd_bind_vertex_buffers2.expect(crate::NOT_LOADED_MESSAGE);
        let binding_count = buffers
            .len()
            .min(offsets.len())
            .min(sizes.len())
            .min(strides.len());
        let _return = _function(
            command_buffer as _,
            first_binding as _,
            binding_count as _,
            buffers.as_ptr() as _,
            offsets.as_ptr() as _,
            sizes.as_ptr() as _,
            strides.as_ptr() as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html) · Function
    #[doc(alias = "vkCmdSetDepthTestEnable")]
    pub unsafe fn cmd_set_depth_test_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        depth_test_enable: bool,
    ) -> () {
        let _function = self.cmd_set_depth_test_enable.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, depth_test_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html) · Function
    #[doc(alias = "vkCmdSetDepthWriteEnable")]
    pub unsafe fn cmd_set_depth_write_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        depth_write_enable: bool,
    ) -> () {
        let _function = self
            .cmd_set_depth_write_enable
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, depth_write_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html) · Function
    #[doc(alias = "vkCmdSetDepthCompareOp")]
    pub unsafe fn cmd_set_depth_compare_op(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        depth_compare_op: crate::vk1_0::CompareOp,
    ) -> () {
        let _function = self.cmd_set_depth_compare_op.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, depth_compare_op as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html) · Function
    #[doc(alias = "vkCmdSetDepthBoundsTestEnable")]
    pub unsafe fn cmd_set_depth_bounds_test_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        depth_bounds_test_enable: bool,
    ) -> () {
        let _function = self
            .cmd_set_depth_bounds_test_enable
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, depth_bounds_test_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html) · Function
    #[doc(alias = "vkCmdSetStencilTestEnable")]
    pub unsafe fn cmd_set_stencil_test_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        stencil_test_enable: bool,
    ) -> () {
        let _function = self
            .cmd_set_stencil_test_enable
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, stencil_test_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html) · Function
    #[doc(alias = "vkCmdSetStencilOp")]
    pub unsafe fn cmd_set_stencil_op(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        face_mask: crate::vk1_0::StencilFaceFlags,
        fail_op: crate::vk1_0::StencilOp,
        pass_op: crate::vk1_0::StencilOp,
        depth_fail_op: crate::vk1_0::StencilOp,
        compare_op: crate::vk1_0::CompareOp,
    ) -> () {
        let _function = self.cmd_set_stencil_op.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(
            command_buffer as _,
            face_mask as _,
            fail_op as _,
            pass_op as _,
            depth_fail_op as _,
            compare_op as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html) · Function
    #[doc(alias = "vkCmdSetRasterizerDiscardEnable")]
    pub unsafe fn cmd_set_rasterizer_discard_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        rasterizer_discard_enable: bool,
    ) -> () {
        let _function = self
            .cmd_set_rasterizer_discard_enable
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, rasterizer_discard_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html) · Function
    #[doc(alias = "vkCmdSetDepthBiasEnable")]
    pub unsafe fn cmd_set_depth_bias_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        depth_bias_enable: bool,
    ) -> () {
        let _function = self.cmd_set_depth_bias_enable.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, depth_bias_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html) · Function
    #[doc(alias = "vkCmdSetPrimitiveRestartEnable")]
    pub unsafe fn cmd_set_primitive_restart_enable(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        primitive_restart_enable: bool,
    ) -> () {
        let _function = self
            .cmd_set_primitive_restart_enable
            .expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, primitive_restart_enable as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html) · Function
    #[doc(alias = "vkCreatePrivateDataSlot")]
    pub unsafe fn create_private_data_slot(
        &self,
        create_info: &crate::vk1_3::PrivateDataSlotCreateInfo,
        allocator: Option<&crate::vk1_0::AllocationCallbacks>,
    ) -> crate::utils::VulkanResult<crate::vk1_3::PrivateDataSlot> {
        let _function = self.create_private_data_slot.expect(crate::NOT_LOADED_MESSAGE);
        let mut private_data_slot = Default::default();
        let _return = _function(
            self.handle,
            create_info as _,
            match allocator {
                Some(v) => v,
                None => std::ptr::null(),
            },
            &mut private_data_slot,
        );
        crate::utils::VulkanResult::new(_return, private_data_slot)
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html) · Function
    #[doc(alias = "vkDestroyPrivateDataSlot")]
    pub unsafe fn destroy_private_data_slot(
        &self,
        private_data_slot: crate::vk1_3::PrivateDataSlot,
        allocator: Option<&crate::vk1_0::AllocationCallbacks>,
    ) -> () {
        let _function = self.destroy_private_data_slot.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(
            self.handle,
            private_data_slot as _,
            match allocator {
                Some(v) => v,
                None => std::ptr::null(),
            },
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html) · Function
    #[doc(alias = "vkSetPrivateData")]
    pub unsafe fn set_private_data(
        &self,
        object_type: crate::vk1_0::ObjectType,
        object_handle: u64,
        private_data_slot: crate::vk1_3::PrivateDataSlot,
        data: u64,
    ) -> crate::utils::VulkanResult<()> {
        let _function = self.set_private_data.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(
            self.handle,
            object_type as _,
            object_handle as _,
            private_data_slot as _,
            data as _,
        );
        crate::utils::VulkanResult::new(_return, ())
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html) · Function
    #[doc(alias = "vkGetPrivateData")]
    pub unsafe fn get_private_data(
        &self,
        object_type: crate::vk1_0::ObjectType,
        object_handle: u64,
        private_data_slot: crate::vk1_3::PrivateDataSlot,
    ) -> u64 {
        let _function = self.get_private_data.expect(crate::NOT_LOADED_MESSAGE);
        let mut data = Default::default();
        let _return = _function(
            self.handle,
            object_type as _,
            object_handle as _,
            private_data_slot as _,
            &mut data,
        );
        data
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html) · Function
    #[doc(alias = "vkCmdCopyBuffer2")]
    pub unsafe fn cmd_copy_buffer2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        copy_buffer_info: &crate::vk1_3::CopyBufferInfo2,
    ) -> () {
        let _function = self.cmd_copy_buffer2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, copy_buffer_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html) · Function
    #[doc(alias = "vkCmdCopyImage2")]
    pub unsafe fn cmd_copy_image2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        copy_image_info: &crate::vk1_3::CopyImageInfo2,
    ) -> () {
        let _function = self.cmd_copy_image2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, copy_image_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html) · Function
    #[doc(alias = "vkCmdBlitImage2")]
    pub unsafe fn cmd_blit_image2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        blit_image_info: &crate::vk1_3::BlitImageInfo2,
    ) -> () {
        let _function = self.cmd_blit_image2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, blit_image_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html) · Function
    #[doc(alias = "vkCmdCopyBufferToImage2")]
    pub unsafe fn cmd_copy_buffer_to_image2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        copy_buffer_to_image_info: &crate::vk1_3::CopyBufferToImageInfo2,
    ) -> () {
        let _function = self.cmd_copy_buffer_to_image2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, copy_buffer_to_image_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html) · Function
    #[doc(alias = "vkCmdCopyImageToBuffer2")]
    pub unsafe fn cmd_copy_image_to_buffer2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        copy_image_to_buffer_info: &crate::vk1_3::CopyImageToBufferInfo2,
    ) -> () {
        let _function = self.cmd_copy_image_to_buffer2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, copy_image_to_buffer_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html) · Function
    #[doc(alias = "vkCmdResolveImage2")]
    pub unsafe fn cmd_resolve_image2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        resolve_image_info: &crate::vk1_3::ResolveImageInfo2,
    ) -> () {
        let _function = self.cmd_resolve_image2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, resolve_image_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html) · Function
    #[doc(alias = "vkCmdSetEvent2")]
    pub unsafe fn cmd_set_event2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        event: crate::vk1_0::Event,
        dependency_info: &crate::vk1_3::DependencyInfo,
    ) -> () {
        let _function = self.cmd_set_event2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, event as _, dependency_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html) · Function
    #[doc(alias = "vkCmdResetEvent2")]
    pub unsafe fn cmd_reset_event2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        event: crate::vk1_0::Event,
        stage_mask: crate::vk1_3::PipelineStageFlags2,
    ) -> () {
        let _function = self.cmd_reset_event2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, event as _, stage_mask as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html) · Function
    #[doc(alias = "vkCmdWaitEvents2")]
    pub unsafe fn cmd_wait_events2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        events: &[crate::vk1_0::Event],
        dependency_infos: &[crate::vk1_3::DependencyInfoBuilder],
    ) -> () {
        let _function = self.cmd_wait_events2.expect(crate::NOT_LOADED_MESSAGE);
        let event_count = events.len().min(dependency_infos.len());
        let _return = _function(
            command_buffer as _,
            event_count as _,
            events.as_ptr() as _,
            dependency_infos.as_ptr() as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html) · Function
    #[doc(alias = "vkCmdPipelineBarrier2")]
    pub unsafe fn cmd_pipeline_barrier2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        dependency_info: &crate::vk1_3::DependencyInfo,
    ) -> () {
        let _function = self.cmd_pipeline_barrier2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, dependency_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html) · Function
    #[doc(alias = "vkQueueSubmit2")]
    pub unsafe fn queue_submit2(
        &self,
        queue: crate::vk1_0::Queue,
        submits: &[crate::vk1_3::SubmitInfo2Builder],
        fence: crate::vk1_0::Fence,
    ) -> crate::utils::VulkanResult<()> {
        let _function = self.queue_submit2.expect(crate::NOT_LOADED_MESSAGE);
        let submit_count = submits.len();
        let _return = _function(
            queue as _,
            submit_count as _,
            submits.as_ptr() as _,
            fence as _,
        );
        crate::utils::VulkanResult::new(_return, ())
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html) · Function
    #[doc(alias = "vkCmdWriteTimestamp2")]
    pub unsafe fn cmd_write_timestamp2(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        stage: crate::vk1_3::PipelineStageFlags2,
        query_pool: crate::vk1_0::QueryPool,
        query: u32,
    ) -> () {
        let _function = self.cmd_write_timestamp2.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(
            command_buffer as _,
            stage as _,
            query_pool as _,
            query as _,
        );
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html) · Function
    #[doc(alias = "vkCmdBeginRendering")]
    pub unsafe fn cmd_begin_rendering(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
        rendering_info: &crate::vk1_3::RenderingInfo,
    ) -> () {
        let _function = self.cmd_begin_rendering.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _, rendering_info as _);
        ()
    }
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html) · Function
    #[doc(alias = "vkCmdEndRendering")]
    pub unsafe fn cmd_end_rendering(
        &self,
        command_buffer: crate::vk1_0::CommandBuffer,
    ) -> () {
        let _function = self.cmd_end_rendering.expect(crate::NOT_LOADED_MESSAGE);
        let _return = _function(command_buffer as _);
        ()
    }
}
///Provided by [`crate::vk1_3`]
impl crate::InstanceLoader {
    #[inline]
    #[track_caller]
    ///[Vulkan Manual Page](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html) · Function
    #[doc(alias = "vkGetPhysicalDeviceToolProperties")]
    pub unsafe fn get_physical_device_tool_properties(
        &self,
        physical_device: crate::vk1_0::PhysicalDevice,
        tool_count: Option<u32>,
        tool_properties_callback: impl FnMut(
            &mut crate::SmallVec<crate::vk1_3::PhysicalDeviceToolProperties>,
        ) -> (),
    ) -> crate::utils::VulkanResult<
            crate::SmallVec<crate::vk1_3::PhysicalDeviceToolProperties>,
        > {
        let _function = self
            .get_physical_device_tool_properties
            .expect(crate::NOT_LOADED_MESSAGE);
        let mut tool_count = match tool_count {
            Some(v) => v,
            None => {
                let mut v = Default::default();
                _function(physical_device as _, &mut v, std::ptr::null_mut());
                v
            }
        };
        let mut tool_properties = crate::SmallVec::from_elem(
            Default::default(),
            tool_count as _,
        );
        let mut _callback = tool_properties_callback;
        _callback(&mut tool_properties);
        let _return = _function(
            physical_device as _,
            &mut tool_count,
            tool_properties.as_mut_ptr(),
        );
        crate::utils::VulkanResult::new(_return, tool_properties)
    }
}
