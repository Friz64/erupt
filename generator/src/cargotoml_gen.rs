use crate::source::Source;
use itertools::Itertools;
use std::{fs, path::Path};

const CARGOTOML: &str = r#"
# THIS FILE IS AUTOGENERATED - DO NOT EDIT IT

[package]
name = "erupt"
version = "0.18.0+174"
authors = ["Friz64 <friz64mc@gmail.com>"]
license = "Zlib"
description = "Vulkan API bindings"
documentation = "https://docs.rs/erupt"
repository = "https://gitlab.com/Friz64/erupt"
readme = "../README.md"
keywords = ["gamedev", "graphics", "vulkan", "bindings"]
categories = ["api-bindings", "game-development", "graphics", "rendering::graphics-api"]
edition = "2018"

[dependencies]
bitflags = "1.2"
libloading = { version = "0.7", optional = true }
raw-window-handle = { version = "0.3", optional = true }
bytemuck = { version = "1.5", optional = true }

[target.'cfg(any(target_os = "macos", target_os = "ios"))'.dependencies]
raw-window-metal = { version = "0.1", optional = true }

[features]
default = ["loading", "surface"]
loading = ["libloading"]
surface = [
    "raw-window-handle",
    "raw-window-metal",
    "khr_wayland_surface",
    "khr_xlib_surface",
    "khr_xcb_surface",
    "khr_android_surface",
    "ext_metal_surface",
    "khr_win32_surface",
]

# autogenerated extension features
"#;

pub fn generate<P>(path: P, source: &Source)
where
    P: AsRef<Path>,
{
    let cargotoml = CARGOTOML.trim_start().to_string();
    let extension_features = source
        .extension_requires
        .iter()
        .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
        .map(|(extension_name, requires)| {
            let requires = requires
                .iter()
                .map(|require_name| format!("\"{}\"", ext_feature_name(require_name)))
                .join(", ");

            format!("{} = [{}]\n", ext_feature_name(extension_name), requires)
        })
        .join("");

    fs::write(path, cargotoml + &extension_features).expect("Failed to write Cargo.toml");
}

pub fn ext_feature_name(name: &str) -> String {
    name.trim_start_matches("VK_").to_lowercase()
}
