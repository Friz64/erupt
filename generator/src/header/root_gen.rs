use crate::{declaration::Type, items::constants, XmlNode};
use log::error;
use regex::Regex;
use std::{
    fs,
    path::{Path, PathBuf},
};

const EXCLUDED_HEADERS: &[&str] = &["vk_platform.h"];
const HEAD: &str = "\
// THIS FILE IS AUTOGENERATED - DO NOT EDIT IT

#define VKAPI_ATTR
#define VKAPI_CALL
#define VKAPI_PTR
";

pub fn generate(
    root_header_path: &Path,
    include_vulkan: &Path,
    other_includes_headers: &[PathBuf],
    registry: XmlNode,
) {
    let mut output = String::from(HEAD);

    let types = registry
        .children()
        .find(|n| n.has_tag_name("types"))
        .expect("No `types` in registry");

    let mut typedef_names = Vec::new();
    for ty in types.children() {
        if let (Some(name), Some(requires)) = (ty.attribute("name"), ty.attribute("requires")) {
            let not_already_defined = !other_includes_headers
                .iter()
                .any(|include| include.ends_with(requires));

            if requires.ends_with(".h") && not_already_defined {
                typedef_names.push(name);
            }
        }
    }

    for typedef_name in typedef_names {
        if Type::try_from_external(typedef_name).is_none() {
            error!("Missing `try_from_external` mapping for {:?}", typedef_name)
        }

        output.push_str(&format!("typedef void {};\n", typedef_name));
    }

    let header_regex = Regex::new(r#"#include "(.+\.h)""#).unwrap();
    let vulkan_h_path = include_vulkan.join("vulkan.h");
    let vulkan_h = fs::read_to_string(vulkan_h_path).expect("Failed to read vulkan.h");
    for include in header_regex.captures_iter(&vulkan_h) {
        let header_name = &include[1];
        if !EXCLUDED_HEADERS.contains(&header_name) {
            output.push_str(&format!("#include \"{}\"\n", header_name));
        }
    }

    constants::header_ext(&mut output, registry);

    fs::write(root_header_path, output).expect("Failed to write root header");
}
