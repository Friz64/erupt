use crate::{declaration::Type, items::constants, XmlNode};
use log::error;
use regex::Regex;
use std::{
    fs,
    path::{Path, PathBuf},
};

pub fn generate(
    root_header_path: &Path,
    include_vulkan: &Path,
    other_includes_headers: &[PathBuf],
    registry: XmlNode,
) {
    let mut output = String::from("// THIS FILE IS AUTOGENERATED - DO NOT EDIT IT\n");

    let types = registry
        .children()
        .find(|n| n.has_tag_name("types"))
        .expect("No `types` in registry");

    let mut typedef_names = Vec::new();
    for ty in types.children() {
        if let (Some(name), Some(requires)) = (ty.attribute("name"), ty.attribute("requires")) {
            let not_already_defined = !other_includes_headers
                .iter()
                .any(|include| include.ends_with(requires));

            if requires.ends_with(".h") && not_already_defined {
                typedef_names.push(name);
            }
        }
    }

    for typedef_name in typedef_names {
        if Type::try_from_external(typedef_name).is_none() {
            error!("Missing `try_from_external` mapping for {:?}", typedef_name)
        }

        output.push_str(&format!("typedef void {};\n", typedef_name));
    }

    let header_regex = Regex::new(r#"#include "(.+\.h)""#).unwrap();
    let vulkan_h_path = include_vulkan.join("vulkan.h");
    let vulkan_h = fs::read_to_string(vulkan_h_path).expect("Failed to read vulkan.h");
    for include in header_regex.captures_iter(&vulkan_h) {
        output.push_str(&format!("#include \"{}\"\n", &include[1]));
    }

    constants::header_ext(&mut output, registry);

    fs::write(root_header_path, output).expect("Failed to write root header");
}
